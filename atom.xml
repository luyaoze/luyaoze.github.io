<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyz的博客</title>
  
  <subtitle>静静地搬砖</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luyaoze.github.io/"/>
  <updated>2018-04-08T16:05:18.908Z</updated>
  <id>http://luyaoze.github.io/</id>
  
  <author>
    <name>卢耀泽</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DDD(三）</title>
    <link href="http://luyaoze.github.io/2018/04/08/DDD-%E4%B8%89%EF%BC%89/"/>
    <id>http://luyaoze.github.io/2018/04/08/DDD-三）/</id>
    <published>2018-04-08T13:07:16.000Z</published>
    <updated>2018-04-08T16:05:18.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDD-三）"><a href="#DDD-三）" class="headerlink" title="DDD(三）"></a>DDD(三）</h1><p>大多数开发将关注点放在数据源上，而不是领域上。这对DDD新手来说也是如此，因为在软件开发中，数据库依然占据主导地位。我们首先考虑的是数据的属性（对应的数据库的列）和关联关系（外建关联），而不是富有行为的领域概念。这样做的结果是将数据模型直接反应在对象模型上，导致那些表示领域模型的实体包含了大量的getter和setter方法。另外，还存在大量的工具可以帮助我们生成这样的实体模型。虽然在实体模型中加入getter和setter并不是什么大错，但是这却不是DDD的做法。</p><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><ul><li>用户提供唯一标识<br>  一般我们采用数据库自动生成的机制，例如oracle的序列，mysql的自增</li><li>程序提供标识<br>  比较著名的就是java当中的UUID。</li><li>另一个限界上下文提供唯一标识<br>  例如用户名和密码做唯一索引。</li></ul><p>标识要保证全局唯一性，并且是安全的，不允许修改的，这里就涉及到一个认证的机制，例如我们现在的开发中，根据页面传过来的序列号进行查询，只有通过这个序列号能在数据库当中找到对应的唯一一条数据才允许进行update操作，否则就认为此次修改是无效的。</p><p>举个简单的例子，在身份访问的上下文中：</p><blockquote><pre><code>1.用户（User）存在于某个租户（Tenant）之下，并受该租户控制2.必须对该系统中的用户（User）进行认证3.User可以处理自己的个人信息，包括名字和联系方式等4.User的个人信息可以被其本人和Manage修改5.User的安全密码是可以修改的</code></pre></blockquote><p>Tenant实体必须有个名字，它的name属性可以是简单的字符串，因为name并没有特殊的行为。Tenant中的name属性有助于查询操作，比如帮助中心的服务人员可以通过name属性来查找出需要服务的Tenant。因此，name属性是必要的，并且Tenant实体的“本质特征”。同时，我们也可以将唯一约束加在name属性上，但这并不是重点。<br>我们还可以向Tenant添加另外的属性，比如售后支持联系人信息、支付人信息等，但是这些都是业务层面的概念，而不是安全层面的。<br>售后支持可以通过另一个限定上下文来管理了。在通过name找到对应的Tenant之后美，系统便可以使用Tenant的唯一标识TenantId了。该TenantId可以进一步用于售后支持上下文中，付账上下文或者客户关系上下文。售后支持联系人，租户地址和租户联系人与安全没有什么关系。另外，将名字name属性加在Tenant上也可以售后支持人员快速地为客户提供服务。<br>在Tenant之后，什么可以做为User实体的唯一标识呢？多数身份系统都为user定义了一个唯一用户宁userName。一个userName由什么组成并不重要，只要它能够在Tenant中唯一地表示一个User即可（相同的userName可以出现在不同的Tenant中）。通常来说，userName由用户自己指定。如果订阅租户对于用户名做出了限制，或者用户名由联合安全机制所决定，那么注册用户需要服从这些限制。所以只需要简单的在userName实体上定义一个userName属性。<br>由于需要满足另一个需求是用户需要提供安全密码，所以向User实体添加一个password属性，由于password绝对不能是明文，所以要对密码进行加密，这就暗示着需要某种形式的领域服务（Domain Service）。所以现在重新对租户和用户定义：</p><blockquote><pre><code>租户：一个有名字的企业订阅方，它提供身份访问与访问服务，同时还包括其他的在线服务。租户向用户发出注册邀请，并处理用户注册过程。用户：一个租户下的注册用户，包含有个人名字和联系信息。一个用户拥有唯一的用户名和密码。加密服务：对密码或其他敏感信息进行加密</code></pre></blockquote><p>还有一个问题就是是否要将username和password合为一个对象，比如名为SecurityPrincipal，这样可以更加清晰地表达安全概念。这是一个有趣的想法。因为很多情况下是根据用户名和密码去查找数据库当中是否有对应的一个记录。但是它忽略了一个重要的需求：密码是可以修改的，另外，有时在查找User的时候，我们并不需要提供密码，如果将这两列做为联合索引，那么每次修改密码将会使数据库索引重排序，所以是没有必要的。</p><h2 id="挖掘实体的关键行为"><a href="#挖掘实体的关键行为" class="headerlink" title="挖掘实体的关键行为"></a>挖掘实体的关键行为</h2><p>在识别出实体的重要属性之后，我们开始挖掘实体的行为。。。。。<br>当我们思考激活（Activate）或者禁用（Deactivate）一个Tenant时，我们想的可能是一个布尔开关，至于如何实现这个开关在这里并不重要。如果我们将一个activate属性添加在Tenant类图中，别人在看到这张类图时，他能够指导activate表达的是什么意思吗？例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tenant</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> active;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的active恐怕并不能够完全表达出它的意图。在开始的时候，我们将关注点放在对身份和查询有用的属性上，之后我们希望通过相似的方法加入一些服务相关的信息。<br>其实更好的办法就是用一个意图展现接口，它更符合领域的设计。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teanant</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//TODO 实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> deactivate&#123;</span><br><span class="line">        <span class="comment">//TODO 实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单一点说就是给相应的领域对象添加行为。相应的我们前面的对于Tenant的定义也需要增加了：</p><blockquote><pre><code>激活租户：通过该操作激活一个租户，激活后再对租户的当前状态进行确认。禁用租户：通过该操作禁用一个租户，在禁用租户时，用户可能还没有被认证。认证服务：协调对用户的认证过程，首先需要保证他们所属的租户处于激活状态。</code></pre></blockquote><p>领域模型是慢慢迭代的，要想一次建好领域模型是不存在的。在这次迭代过程中我们发现了另一个领域服务。在对User实例进行匹配之前，我们需要调用Tenant的isActivate()方法来检查租户的活跃状态，我们也可以通过一下需求看出该认证服务的必要性：</p><ul><li>系统必须对User进行认证，并且只有当Tenant处于激活状态时才能对User进行认证</li></ul><p>可以看出，提供User的username和password信息只是认证用户的其中一个步骤，因此我们需要更高层面的认证协调者。领域服务便能很好地完成这样的任务。我们可以在后面再加入额外的细节。<br>同时考虑一下需求：</p><ul><li>通过邀请，租户允许用户进行注册</li></ul><p>当我们仔细分析这项需求时，我们发现该需求比先前想象的要复杂。这里似乎需要一个注入Invitation的对象，但是需求并没有提供足够的信息，管理邀请的行为也不清晰，因此等到又了更多的输入信息时才继续。然而我们需要创建registerUser()方法。<br>先前对于User的理解：</p><blockquote><pre><code>User处理自己的信息，包括名字和联系方式User个人的信息可以被其本人和Manager修改User的安全密码时可以被修改的</code></pre></blockquote><p>这里我们使用两种经常联合使用的安全模式–用户和基本身份。很明显，“个人”的概念伴随着“User”的概念。基于以上对于User的理解，我们需要创建一个Person类，以免将过多的指责放在User类上。上面的“个人的”一词定义如下：</p><ul><li>个人：包含并管理用户的个人信息，包括名字和联系方式等。</li></ul><p>这里的Person时实体还是值对象呢？同样，“修改”一词时关键。我们似乎没有必要要在一个用户修改电话号码时就将整个Person对象替换掉，因此我们将其建模成了实体，暂时，这个Person包含了两个值对象–ContactInfomation和Name，这些都是比较模糊的概念，之后在必要的时候将其进行重构。<br>这里还需要思考一下如何管理用户的名字和联系信息呢。客户端访问到User中的Person对象吗？这里的一个User是否总是一个Person呢？如果User表示的是一个外部的系统，又该怎么办呢？如果我们允许客户访问Person，那么客户端的代码可能需要进行重构了。<br>反之，如果将Person的行为直接放在User上，这可能会避免一些麻烦。是完全地讲Person暴露给外界呢？还是应该向客户隐藏起来？权衡一下，我们设计一个Principal（委托人）接口，而Person和System分别是两种特殊的Principal。<br>考虑最后一条需求所反映的通用语言：</p><ul><li>user的安全密码是可以修改的</li></ul><p>所以User应该拥有一个changePassword（）方法。客户是绝对不能访问到密码的，哪怕是加密之后的密码也不行。在设置了密码之后，该密码是不会暴露在聚合边界之外的。所有需要和安全认证打交道的代码都必须通过AuthenticationService。</p><h2 id="角色和职责"><a href="#角色和职责" class="headerlink" title="角色和职责"></a>角色和职责</h2><p>建模的一个方面便是发现对象的角色和职责。通常来说，对角色和职责分析是可以应用在领域对象上的。这里我们特别关注的是实体的角色和职责。<br>对于“角色”这个概念，我们需要一些上下文来理解。在身份与访问上下文中，一个角色是一个实体，同时是身份安全领域中的一个聚合根。也就是模型中的对象可以扮演什么样的角色。</p><ul><li><p>领域对象扮演多种角色</p><p>  在面向对象编程中，通常由接口定义来定义实现类的角色。在正确设计的情况下，一个类对于每一个实现它所实现的接口来说，都存在一种角色。如果一个类没有显示的角色–即该类没有实现任何形式的接口，那么在默认情况下它扮演的即是本类的角色。也即，该类的公有方法表示该类的隐式接口。比如，上面的User类并没有实现任何接口，但是它依然扮演了一种角色，即User角色。<br>  我们可以使一个对象同时扮演User和person的角色，虽然这并不是我所建议的，但就目前而言，让我们假设这时一个好主意。这样一来，我们便没有必要在User中引用一个Person<br>了，而是只需要创建一个对象来同时扮演这两种角色即可。<br>  那我们为什么要这么做呢？通常是因为两个或多个对象既有相似之处，又有不同之处。此时，这些对象上重叠的属性可以通过一个实现了多个接口的对象来表示。比如，我们可以创建一个HumanUser对象，该对象既是一个User，又是一个Person。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HumanUser</span> <span class="keyword">implements</span> <span class="title">User</span>, <span class="title">Person</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码看似合情合理，但是它也可能使事情变得复杂。如果两个接口都是复杂的，那么HumanUser对象实现起来将是困难的，另外，如果User不是一个人，而是一个系统又该怎么办？此时我们可能需要3个接口，而要设计一个实现3个接口的对象将变得更加困难。<br>以上的设计存在多个问题，其中之一便是对象分裂症。对象分裂症的描述是：委派对象根本不知道原来被委派独享的身份标识，因此我们无法知道委派对象的真正身份。<br>当然，角色接口最实用之处也是其最简单之处。通过接口，我们可以将实现细节隐藏起来，从而不至于将实现细节泄漏到客户端中。我们所设计的接口应该刚好能够满足客户端的需求，不多也不少。实现类可以比复杂接口复杂多，它可以拥有大量的支撑性属性，外加这些属性的getter和setter方法。但是客户端是看不到这些细节的。比如，有些工具或框架可能强制性地要求在类上创建共有方法，而我们并不希望客户端调用这些公有的方法。即便如此，领域模型接口也不会被技术上的实现细节所影响。显然，这时一个领域建模方面的好处。<br>不管采用哪种设计方式，我们都应该确保领域语言优于技术实现。在DDD中，业务领域的模型才是最重要的。</p><ul><li>创建实体</li></ul><p>当我们创建一个实体时，我们希望通过构造函数来初始化足够多的实体状态，这一方面有助于表明该实体的身份，另一方面可以帮助客户端更容易地查找该实体。在使用及早生成唯一标识的策略时，构造函数至少需要接受一个唯一标识做为参数。但是根据我们现在的业务需要，每次都是根据实体类的主键去数据库中查询，所以这个根据自己具体的业务来对待吧，没有最好的方案，只有最合适的方案。</p><h2 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a>值对象</h2><p>值对象虽然经常被掩盖在实体的阴影之下，但它确实非常重要的DDD部件。其实我们现在业务系统当中使用的所有的用@Entity标注的对象都是值对象。因为必须显示地调用DAO层的save（）方法才能对值对象进行保存或者修改。如果借助EntityManger这个类托管的对象，你只要调用它的setter方法之后，Hibernate会自动执行一条update的sql语句对该对象进行更新。用值对象来建模，好处就是非常容易地对值对象进行创建、测试、使用、优化和维护，并不需要担心修改了某一个属性就修改了数据库。而且值对象拥有可替换行，整体性，无副作用等特点。</p><p>未完待续～～～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DDD-三）&quot;&gt;&lt;a href=&quot;#DDD-三）&quot; class=&quot;headerlink&quot; title=&quot;DDD(三）&quot;&gt;&lt;/a&gt;DDD(三）&lt;/h1&gt;&lt;p&gt;大多数开发将关注点放在数据源上，而不是领域上。这对DDD新手来说也是如此，因为在软件开发中，数据库依然占据主
      
    
    </summary>
    
      <category term="java" scheme="http://luyaoze.github.io/categories/java/"/>
    
      <category term="DDD" scheme="http://luyaoze.github.io/categories/java/DDD/"/>
    
    
      <category term="DDD" scheme="http://luyaoze.github.io/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>DDD(二)</title>
    <link href="http://luyaoze.github.io/2018/04/06/DDD-%E4%BA%8C/"/>
    <id>http://luyaoze.github.io/2018/04/06/DDD-二/</id>
    <published>2018-04-06T14:01:19.000Z</published>
    <updated>2018-04-06T17:44:43.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDD-二"><a href="#DDD-二" class="headerlink" title="DDD(二)"></a>DDD(二)</h1><ul><li><p>理解限界上下文</p><p>  限界上下文是一个显式边界，领域模型便存在于边界之内。在边界内，通用语言的所有属于和词组都有特定的含义，而模型需要准备地反应通用语言。<br>  例如账户（Account）模型在银行上下文（Banking Context）和文学上下文（Literary Context）中是完全不同的。在银行上下文，账户表示一个客户在银行存款的状态，并记录每次交易的信息。而在文学上下文中，账户表示文字记录的在一段时间之内发生的一系列事件。<br>  所以说上下文才是王道，特别是在实施DDD的时候。<br>  当需要集成时，我们必须在不同的限界上下文之间进行概念映射。在DDD中，这可能是复杂的，因此我们应该特别留意。在上下文边界之外，我们通常不会使用该上下文之内的对象实例，但是不同上下文中彼此关联的对象可能共享一些状态。<br>  再看另一个例子，该例中同一个领域的不同限界上下文使用了相同的概念名。考虑一个图书出版机构，它需要处理图书生命周期的不同阶段。粗略地讲，我们可以认为这些不同的阶段对应于以下不同的上下文环境：</p><ul><li>概念设计，计划出书</li><li>联系作者，签订合同</li><li>管理图书的编辑过程</li><li>设计图书布局，包括插图</li><li>将图书翻译成其它语言</li><li>出版纸质或电子版图书</li><li>市场营销</li><li>将图书卖给销售商或者直接卖给读者</li><li><p>将图书发送给销售商或读者</p><p>在以上所有阶段中，我们可以用一个单一的概念对图书建模吗？显然不行。在每个阶段中，“图书”都有不同的定义。一本书只有在和作者签订了合同之后才能拥有书名，而书名可能在编辑过程进行修改。在编辑过程中，图书包含了一系列的稿件，其中包括注视和较正等，之后会有一份最终稿件。页面布局由专门的图形设计师完成。图书印刷方使用页面布局和封面版式印制图书。市场营销员不需要编辑稿件或图书印制成品，他们可能只需要图书的简介即可。对于如数的售后物流吗，我们需要的是图书的标识码、物流目的地、数目、尺寸和重量等。<br>想象一下，如果我们使用一个单一模型来处理所有这些阶段会发生什么？概念混淆、意见分歧和争论是不可避免的，我们所交付的软件也没有多大价值。即便有时我们可能会得到一个正确的公共模型，但这种模型并不具有持久性。<br>为了解决这个问题，我们应该为每个阶段创建个字的限界上下文，在每个限界上下文中，都存在某种类型的图书（Book）。在几乎所有的上下文中，不同类型的图书对象将共享一个身份标识（identity），这个标识可能是在概念设计阶段创建的。然而，不同上下文中的图书模型确实不同的。当某个限界上下文的团队说到图书时，该“图书”正好能表示该上下文所需要的意思。如此这般，我们根据不同的需求很自然地创建了不同类型的图书，但这并不表示这种建模过程就是可以轻易达到的。不管如何，在使用显式限界上下文的情况下，我们可以定期地、增量式的交付软件，同时所交付的软件又能满足特定的业务需求。</p></li></ul></li></ul><h2 id="限界上下文不仅仅只是包含模型"><a href="#限界上下文不仅仅只是包含模型" class="headerlink" title="限界上下文不仅仅只是包含模型"></a>限界上下文不仅仅只是包含模型</h2><p>一个限界上下文并不是只包含模型领域。诚然，模型时限界上下文的主要“公民”。但是，限界上下文并不局限于容纳模型，它通常标定了一个系统、一个应用程序或者一种业务服务。有时，限界上下文所包含的内容可能比较少，比如，一个通用子域便可以只包含领域模型</p><ul><li><p>限界上下文的大小</p><p>  限界上下文中可以包含多少领域模型中的基础部件呢，比如模块、聚合、领域事件和领域服务等？这好像是在问“一个字符串应该有多长？”一样。限界上下文应该足够大，以便能够表达它所对应的整套通用语言。<br>  核心领域之外的概念不应该包含在限界上下文中。如果一个概念不属于你的通用语言，那么一开始你就不应该将其引入到模型中。此外，如果有外部概念“偷偷潜入”了你的限界上下文，你需要将其清除，他们可能属于另外的支撑子域或者通用子域，或者根本就不属于某个领域模型。<br>  如果对限界上下文的限制过于严格，那么我们可能丢失一些上下文概念。相反，如果向模型中添加过多的概念，我们可能搞不清楚哪些概念是重要的。那么我们的目标是什么呢？如果我们的模型是音乐，那么它应该表现出的是完整性、纯洁性、力量、优雅和美。其中的“音符”–模块、聚合、事件和服务–的数量正好是设计所要求的那么多。模型的“听众”不会问及到像“为什么中间会有一些奇怪的音符？”这样的问题。同时，他们也不会因为丢失了某些“音符”而感到不解。</p></li></ul><h2 id="上下文映射图"><a href="#上下文映射图" class="headerlink" title="上下文映射图"></a>上下文映射图</h2><p>一个项目的上下文映射图可以用两种方式来表示。比较容易的一种是画一个简单的框图来表示两个或多个限界上下文之间的映射关系。该框图表示了不同的限界上下文在解决方案空间中是如何通过集成相互关联的。另一种更详细的方式是通过限界上下文集成的源代码实现来表示。<br>在开始采用DDD时，首先你应该为你当前的项目绘制一个上下文映射图，其中应该包含你项目中当前的限界上下文和他们之间的集成关系。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>DDD的一大好处便是它并不需要使用特定的架构。由于核心域位于界限上下文中，我们可以在整个系统中使用多种风格的架构。有些架构包围着领域模型，能够全局性地影响系统，而有些架构则满足了某些特定的需求。我们的目标时选择适合于自己的架构和架构模式。<br>在选择架构风格和架构模式时，我们应该将软件质量考虑在内，而同时，避免滥用架构风格和架构模式也是重要的。质量驱动的架构选择是种风险驱动方式，即我们采用的架构是用来减少失败风险的美，而不是增加失败风险。因此，我们必须对每种架构做出正确的评估。<br>对架构风格和模式的选择受到功能需求的限制，比如用例或用户故事。换句话说，在没有功能需求的情况下，我们是不能对软件质量做出评判的美，亦不能做出正确的架构选择。这也说明用例驱动架构在当今的软件开发中依然适用。<br>当然，分层架构的原则依然可以作为我们的决策指导，但是我们不会止步不前，我们将在必要时采用更现代的架构和模式，这也意味着DDD的用途是非常广阔的。<br>分层架构的一个重要原则是：每层只能与位于其下方的层发生耦合。分层架构也分为几种：在严格分层架构中，某层只能与直接位于其下方的层发生耦合；而松散分层架构则允许任意上方层与任意下方层发生耦合。由于用户界面层和应用服务通常需要与基础设施打交道，许多系统都是基于松散分层架构的。<br>事实上，较低层也是可以和较高层发生耦合的，但这只是局限于采用观察者模式或者调停者模式的情况。较低层是绝对不能访问较高层的。例如，在使用调停者模式时，较高层可能实现了较低层定义的接口，然后将实现对象对象作为参数传递到较低层。当较低层调用该实现时，它并不知道实现出自何处。<br>用户界面只用于处理用户显示和用户请求，它不应该包括领域或业务逻辑。有人可能会认为，既然用户界面需要对用户输入进行验证，那么它就应该包含业务逻辑。事实上，用户界面所进行的验证和对领域模型的验证时不同的，对于那些粗制滥造的，并且只面向领域的验证行为，我们依然予以限制。<br>如果用户界面使用了领域模型中的对象，那么此时的领域对象仅限于数据的渲染展现。在采用这种方式时，可以使用展现模型对用户界面与领域对象进行解耦。</p><ul><li>六边形架构 </li><li>REST架构</li><li><p>依赖倒置原则</p><p>  有一种方法可以改进分层架构–依赖倒置原则，它通过改变不同层之间的依赖关系达到改进目的。依赖倒置原则正式的定义为：</p><ul><li>高层模块不应该依赖于低层模块，两者都应该依赖于抽象。</li><li>抽象不应该依赖细节，细节应该依赖抽象。</li></ul></li><li><p>REST和DDD<br>  RESTful HTTP是具有诱惑力的，但是我们并不建议将领域模型直接暴露给外界，因为这样会使系统接口变得非常脆弱，原因在于对于领域模型的每次改变都会导致对系统接口的改变。要将DDD与RESTful HTTP合并起来使用，我们有两种方式。<br>  第一种方法是为系统接口层单独创建一个限界上下文，再在此上下文中通过适当的策略来访问实际的核心模型。这是一种经典的方法，它将系统接口看作一个整体没通过资源抽象将系统功能暴露给外界，而不是通过服务或者远程接口。<br>  让我们看一个实际的例子。我们创建一个系统来管理工作组，其中包括任务、计划/预约和子工作组管理等。我们将创建一个纯净的、不受架构影响的领域模型，该模型能正确地反映通用语言，并准确地实现业务逻辑。如果需要为这个领域模型发布一个接口，我们便可以通过REST资源的形式向外提供一个远程接口。这些资源反映了客户所需的用例，他们和领域模型是存在区别的。但是，每一种资源归根结底都创建自核心域，比如核心域中的聚合等。<br>  当然我们也可以简单地使用领域对象来作为JAX-RS的方法参数，比如我们可以将/:user/:task映射到getTask()方法，该方法返回一个task对象。这样看起来是很简单，但却隐藏着一个很大的问题。对Task对象的任何修改都将立即反应到远程接口上，结果有可能使客户端调用失败。而即便我们所做的修改与外界没有任何关系，我们依然不能排除客户端调用失败的可能性。<br>  因此，第一种方法是应该被考虑的，因为它在核心域和系统接口模型之间完成了解耦，这使得我们可以先对领域模型进行修改，然后再决定哪些修改应该反映到系统接口模型上。请注意，在这种方法中，系统接口模型通常是根据领域模型来设计的名单时更好、更自然的方法应该是根据用例来设计。另外，我们还可以为这种方式自定义一种媒体类型。<br>  另一种方法用于需要使用标准媒体类型的时候。如果某种媒体类型并不用于支持单个系统接口么事用于一组相似的客户端-服务器交互场景，此时我们可以创建一个领域模型来处理每一种媒体类型。这样的领域模型甚至可以在服务器和客户端之间进行重用。</p></li><li><p>命令和查询指责分离–CQRS</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DDD-二&quot;&gt;&lt;a href=&quot;#DDD-二&quot; class=&quot;headerlink&quot; title=&quot;DDD(二)&quot;&gt;&lt;/a&gt;DDD(二)&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;理解限界上下文&lt;/p&gt;
&lt;p&gt;  限界上下文是一个显式边界，领域模型便存在于边界之内。在边界内
      
    
    </summary>
    
      <category term="java" scheme="http://luyaoze.github.io/categories/java/"/>
    
      <category term="DDD" scheme="http://luyaoze.github.io/categories/java/DDD/"/>
    
    
      <category term="DDD" scheme="http://luyaoze.github.io/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>DDD领域驱动</title>
    <link href="http://luyaoze.github.io/2018/04/05/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8/"/>
    <id>http://luyaoze.github.io/2018/04/05/DDD领域驱动/</id>
    <published>2018-04-05T13:45:24.000Z</published>
    <updated>2018-04-05T16:56:25.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDD领域驱动"><a href="#DDD领域驱动" class="headerlink" title="DDD领域驱动"></a>DDD领域驱动</h1><p>领域驱动设计（DDD）作为一种软件开发方法，它可以帮助我们设计高质量的软件模型。在正确实现的情况下，我们通过DDD完成的设计恰恰就是软件的工作方式。</p><ul><li><p>什么是领域模型？</p><p>  领域模型是关于某个特定业务领域的软件模型。通常，领域模型通过对象模型来实现，这些对象同时包含了数据和行为，并且表达了准确的业务含义。</p></li><li><p>处理领域复杂性</p><p>  在使用DDD时，我们首先希望将它应用在最重要的业务场景下。对于那些可以轻易替换的软件来说，你是不会有所投入的。相反，值得你投入的是那些重要的、复杂的东西，因为这些东西将为你带来可观的回报。正因如此，我们将这样的模型命名为核心域（Core Domain),而那些相对次要的称为支撑子域（Supporting Subdomain）。那么现在，我们需要搞明白的是，“复杂”到底是什么意思？</p><p>  DDD的作用是简化，而不是复杂化。<br>  在使用DDD时，我们应该采用最简单的方式对复杂领域进行建模，而不是使问题变得更加复杂。</p><p>  不同的业务领域对于复杂的定义是不一样的。另外，不同的公司所面临的挑战是不一样的；成熟度不一样；软件开发能力也不一样。因此，与其去定义什么是复杂的，还不如定义什么是重要的。这时，你的团队和管理层应该做出决定：你们开发的软件系统是否值得做出DDD投入。</p></li><li><p>贫血领域对象</p><p>  领域对象当中只有getter和setter方法，并且几乎没有业务逻辑。<br>  贫血领域对象是不好的，因为你花了很大的成本来开发领域对象，但是从中获益甚少。比如，由于存在对象-关系阻抗失配，开发者需要将很多时间花在对象和数据存储之间的映射上。这样的代价太大，而受益太小。我得说，你所说的领域对象根本就不是领域对象，而只是将关系型数据库中的模型映射到对象上而已。这样的领域对象更像是活动记录，此时你可以对架构做个简化，然后使用事物脚本进行开发。<br>  贫血领域对象反应了一种自然的过程式的编码风格，但我并不认为这是首要原因。我们很多开发者都是学者示例代码做开发的这并不是什么坏事，只要示例代码本身是好的。然而，通常情况是，实例代码只是用尽可能简单的方式来展示某个特定的概念或者API特性，而并不是要强调遵循好多的设计原则。一些极度简化的示例代码总是包含了大量的getter和setter，于是这些getter和setter随着示例代码每天被程序员们原封不动的来回复制。</p></li></ul><h2 id="如何DDD"><a href="#如何DDD" class="headerlink" title="如何DDD"></a>如何DDD</h2><ul><li><p>通用语言</p><p>  通用语言是团队共享的语言。领域专家和开发者使用的相同的语言进行交流。事实上，团队中每个人都是用相同的通用语言。不管你在团队中的角色如何，只要你是团队的一员，你都将使用通用语言。<br>  使用DDD的业务价值<br>  （1）你获得了一个非常有用的领域模型<br>  （2）你的业务得到了更准确的定义和理解<br>  （3）领域专家可以为软件设计做出贡献<br>  （4）更好的用户体验<br>  （5）清晰的模型边界<br>  （6）更好的企业架构<br>  （7）敏捷、迭代和持续建模<br>  （8）使用战略和战术新工具</p></li></ul><p>直接上代码，使用属性访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BacklogItem</span> <span class="keyword">extends</span> <span class="title">Entity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SprintId sprintId;</span><br><span class="line">    <span class="keyword">private</span> BacklogItemStatustype status;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//省略getter和setter方法</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过service设置sprintId和status将一个BacklogItem提交到Sprint中</span></span><br><span class="line">backlogItem.setSprintId(sprintId);</span><br><span class="line">backlogItem.setStatus(BacklogItemStatusType.COMMITTED);</span><br></pre></td></tr></table></figure><p>使用领域对象的行为，这种行为表达出了领域中的通用语言：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BacklogItem</span> <span class="keyword">extends</span> <span class="title">Entity</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SprintId sprintId;</span><br><span class="line">    <span class="keyword">private</span> BacklogItemStatustype status;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitTo</span><span class="params">(Sprint aSprint)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.isSchecduledForRelease())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"状态异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.isCommittedToSprint())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!aSprint.sprintId().equals(<span class="keyword">this</span>.sprintId()))</span><br><span class="line">                <span class="keyword">this</span>.uncommitformSprint();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.elevateStatusWith(BacklogItemStatus.COMMITED);</span><br><span class="line">        <span class="keyword">this</span>.setSprintId(aSprint.sprintId());</span><br><span class="line">        DomainEventPublisher</span><br><span class="line">                            .instance()</span><br><span class="line">                            .publish(<span class="keyword">new</span> BacklogItemCommitted(</span><br><span class="line">                                    <span class="keyword">this</span>.tenant(),</span><br><span class="line">                                    <span class="keyword">this</span>.backlogItemId(),</span><br><span class="line">                                    <span class="keyword">this</span>.sprintId()));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时service代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backlogItem.commitTo(sprint);</span><br></pre></td></tr></table></figure><pre><code>第一个例子采用是以数据为中心的方式，此时客户端代码必须知道如何正确地将一个待定项提交到冲刺中。这样的模型是不能称为领域模型的。如果客户端代码错误地修改了sprintId，而没有修改status会发生什么呢？或者如果在将来有另外一个属性需要设置值又该怎么办呢？我们需要认真分析客户代码来完成从客户数据到BacklogItem属性的映射。这种方法同时也暴露了BacklogItem的数据结构，并且将关注点集中在数据属性上，而不是对象行为。第二个例子，它将行为暴露给客户，行为方法的名字很清楚地表明了业务含义。客户代码并不需要知道提交BacklogItem的细节。实现代码所表达的逻辑恰好能够描述业务行为。我们很容易地添加了几行代码，以确保在发布计划之外的待定项是不能被提交的。很明显，在第二个例子中，我们对BacklogItem有了更多的思考。</code></pre><ul><li><p>领域</p><p>  领域（Domain）即是一个组织所做的事情以及其中所包含的一切。商业机构通常会确定一个市场，然后在这个市场中销售产品和服务。每个组织都有它自己的业务范围和做事方式。这个业务范围以及在其中所进行的活动便是领域。当你为某个组织开发软件的时，你面对的便是这个组织的领域。这个领域对于你来说应该是明晰的，以为你在这个领域中工作。<br>  有一点需要注意的是，“领域”这个词可能承载了太多含义。领域既可以表示整个业务系统，也可以表示其中某个核心领域或者支撑子域。<br>  由于“领域模型”包含了“领域”这个词，我们可能会认为应该为整个业务系统创建一个单一的、内聚的、全功能式的模型。然而，这并不是我们使用DDD的目标。正好相反，在DDD中，一个领域被分为若干子域，领域模型在限界上下文中完成开发。事实上，在开发一个领域模型时，我们关注的通常只是这个业务系统的某个方面。试图创建一个全功能的领域模型好似非常困难的，并且容易导致失败。既然领域模型不能包含整个业务系统，我们应该如何来划分领域模型呢？那就时将这些功能分开对待。<br>  子域并不是一定要做得很大，并且包含很多功能。有时，子域可以简单到只包含一套算法，这套算法可能对于业务系统来说非常重要，但是并不包含在核心领域之中。在正确实施DDD的情况下，这种简单的子域可以以模块的形式从核心域中分离出来，而不需要包含在笨重的子系统组件中。</p></li></ul><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DDD领域驱动&quot;&gt;&lt;a href=&quot;#DDD领域驱动&quot; class=&quot;headerlink&quot; title=&quot;DDD领域驱动&quot;&gt;&lt;/a&gt;DDD领域驱动&lt;/h1&gt;&lt;p&gt;领域驱动设计（DDD）作为一种软件开发方法，它可以帮助我们设计高质量的软件模型。在正确实现的情况下，
      
    
    </summary>
    
      <category term="java" scheme="http://luyaoze.github.io/categories/java/"/>
    
      <category term="DDD" scheme="http://luyaoze.github.io/categories/java/DDD/"/>
    
    
      <category term="DDD" scheme="http://luyaoze.github.io/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>AOP</title>
    <link href="http://luyaoze.github.io/2018/04/02/AOP/"/>
    <id>http://luyaoze.github.io/2018/04/02/AOP/</id>
    <published>2018-04-02T14:02:59.000Z</published>
    <updated>2018-04-02T16:52:35.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><hr><p>我们知道，使用面向对象编程（OOP）有一些弊端，当需要为多个不具有及继承关系的对象引入同一个公共行为时，例如日志、安全检测等，我们只有在每个对象里引用公共行为，这样程序中就产生了大量的重复代码，程序就不便于维护了，所以就有了一个，面向对象编程的补充，即面向切面编程（AOP），AOP所关注的方向时横向的，不同于OOP的纵向。</p><p>使用@AspectJ注解对POJO进行标注，使用AspectJ切点表达式语法进行切点定义，可以通过切点函数、运算符、通配符等高级功能进行切点定义，拥有强大的连接点描述能力。</p><hr><h2 id="动态AOP使用示例"><a href="#动态AOP使用示例" class="headerlink" title="动态AOP使用示例"></a>动态AOP使用示例</h2><hr><p>（1）创建用于拦截的bean<br>    在实际工作中，此bean可能满足业务需要的核心逻辑，例如test方法中可能会封装着某个核心业务，但是，如果我们想在test前后加入日志来跟踪调试，如果直接修改源码并不符合面向对戏那个的设计方法，而且随意改动原有代码也会造成一定的风险，还好接下来的Spring帮我们做到了这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String testStr = <span class="string">"testStr"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTestStr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testStr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestStr</span><span class="params">(String testStr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testStr = testStr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)创建Advisor。<br>Spring中摒弃了最原始的繁杂配置方式而采用@AspectJ注解对POJO进行标注，使AOP的工作大大简化，例如，在AspectJTest类中，我们要做的就是在所有类的test方法执行前在控制台中打印beforeTest，而在所有类的test方法执行后打印afterTest，同时又使用环绕的方式在所有类的方法执行前后再次分别打印before1和after1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsoectJTest</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义切点</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* *.test(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"test()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"beforeTest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"test()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"afterTest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"test()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundTest</span><span class="params">(ProceedingJoinPoint p)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before1"</span>);</span><br><span class="line">        Object o = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            o = p.proceed();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after1"</span>);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)创建配置文件<br>    XML是Spring的基础，尽管Spring配置一再简化，并且大有使用注解取代XML配置之势，但是无论如何，至少现在XML还是Spring的基础。要在Spring中开启AOP够功能，还需要在Spring配置文件中声明&lt;aop:aspectj-autoproxy /&gt;。</p><hr><h2 id="AOP标签属性"><a href="#AOP标签属性" class="headerlink" title="AOP标签属性"></a>AOP标签属性</h2><hr><ul><li><p>proxy-target-class和expose-proxy</p><p>  （1）proxy-target-class</p><p>  SpringAOP部分使用JDK动态代理或者CGLIB来为目标对象创建代理。（建议尽量使用JDK动态代理），如果被代理的目标对象实现了至少一个接口，则会使用JDK动态代理。所有该目标类型实现的接口都将被代理。若该目标对象没有实现任何接口，则创建一个CGLIB代理。如果你希望强制使用CGLIB代理，（例如希望代理目标对象的所有方法，而不是实现自接口的方法）那也可以，但是需要考虑一下两个问题。</p><ul><li>无法通知（advise）Final方法，因为他们不能被重写。</li><li>你需要将CGLIB二进制发行包放在classpath下面。</li></ul></li></ul><p>相比较而言，JDK本身就提供了动态代理，强制使用CGLIB代理需要将aop:config的proxy-target-class属性设为true。<br>当需要使用CGLIB代理和@AspectJ自动代理支持，需要设置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy proxy-target-class="true"&gt;...&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><ul><li>JDK动态代理：其代理对象必须是某个接口的实现，它是通过在运行期间内创建一个接口来实现对目标        对目标对象的代理。</li><li>CGLIB代理：实现原理类似于JDK动态代理，只是它在运行期间生成的代理对象是针对目标类拓展的子类。CGLIB是高效的代码生成包，底层是依靠ASM（开源的Java字节码编辑类库）操作字节码实现的，性能比JDK强。</li><li>expose-proxy：有时候目标对象内部的自我调用将无法实施切面中的增强，如下实例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServiceImpl</span> <span class="keyword">implements</span> <span class="title">AService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> vlid <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>此处的this指向目标对象，因此调用this.b（）将不会执行b事物切面，即不会执行事务增强，因此b方法的事务定义“@Transactional(propagation = Propagation.REQUIRES_NEW)”将不会执行，为了解决这个问题，我们可以这样做</code></pre><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">expose-proxy</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><pre><code>然后将以上代码中的“this.b();”修改为“((AService)AopContext.currentProxy()).b();”即可。通过以上的修改便可以完成对a和b方法的同时增强。最后注册组件并通知，便于监听器做进一步处理。</code></pre><hr><h2 id="静态AOP使用示例"><a href="#静态AOP使用示例" class="headerlink" title="静态AOP使用示例"></a>静态AOP使用示例</h2><hr><p>加载时织入（Load-Time Weaving,LTW）指的是在虚拟机载入字节码文件时动态织入AspectJ切面。Spring框架的值添加为AspectJ LTW在动态织入的过程中提供了更细粒度的控制。使用Java（5+）的代理能使用一个叫“Vanilla”的AspectJ LTW，这需要在启动jvm的时候将某个JVM参数设置为开。这种JVM范围的设置在一些情况下或许不错，但通常情况下显得又些粗颗粒。而用Spring的LTW能让你在per-ClassLoader的基础上打开LTW，这显然更加细粒度并且对“单JVM多应用”的环境更具意义（例如在一个典型应用服务器环境中）。另外，在-javaagent:path/to/aspectjweaver.jar或者-javaagent:path/to/Spring-agent.jar。开发人员只需要简单修改应用上下文的一个或几个文件就能使用LTW，而不需要依靠哪些管理者部署配置。<br>我们还是以之前的AOP实例为基础，如果想从动态代理的方式改成静态代理的方式需要做如下改动。</p><p>（1）Spring全局配置文件的修改，加入LWT开关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:load-time-weaver /&gt;</span><br></pre></td></tr></table></figure><p>(2)加入aop.xml。在class目录下的META-INF（没有则自己建立）文件夹下建立aop.xml，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE aspectj PUBLIC "-//AspectJ//DTD//EN" "http://www.eclipes.org/aspecjt/dtd/aspectj.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aspectj</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">weaver</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">within</span>=<span class="string">"test.*"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">weaver</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">aspects</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"test.AspectJTest"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aspects</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aspectj</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--主要是告诉AspectJ需要对哪个包进行织入，并使用哪些增强器。--&gt;</span></span><br></pre></td></tr></table></figure><p>（3）加入启动参数。如果是Eclipse中启动需要加上启动参数， </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:e:\org.springframework.instrument.jar</span><br></pre></td></tr></table></figure><p>结果跟动态AOP并无差别。静态代理主要是在虚拟机启动的时候通过改变目标对象字节码的方式来完成对目标对象的增强，它与动态代理相比具有更高的效率，因为动态代理调用的过程中，还需要一个动态创建代理类并对代理目标对象的步骤，而静态代理则是在启动时便完成了字节码增强当系统再次调用目标类时与调用正常的类并无差别，所以在效率上会相对高些。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AOP&quot;&gt;&lt;a href=&quot;#AOP&quot; class=&quot;headerlink&quot; title=&quot;AOP&quot;&gt;&lt;/a&gt;AOP&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;我们知道，使用面向对象编程（OOP）有一些弊端，当需要为多个不具有及继承关系的对象引入同一个公共行为时，例如日志、安全检测
      
    
    </summary>
    
      <category term="java" scheme="http://luyaoze.github.io/categories/java/"/>
    
      <category term="spring" scheme="http://luyaoze.github.io/categories/java/spring/"/>
    
      <category term="aop" scheme="http://luyaoze.github.io/categories/java/spring/aop/"/>
    
    
      <category term="aop" scheme="http://luyaoze.github.io/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>Docker+Kubernetes集群+Skaffold快速迭代本地开发应用</title>
    <link href="http://luyaoze.github.io/2018/04/01/Docker-Kubernetes%E9%9B%86%E7%BE%A4-Skaffold%E5%BF%AB%E9%80%9F%E8%BF%AD%E4%BB%A3%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/"/>
    <id>http://luyaoze.github.io/2018/04/01/Docker-Kubernetes集群-Skaffold快速迭代本地开发应用/</id>
    <published>2018-04-01T13:47:59.000Z</published>
    <updated>2018-04-08T13:22:01.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-Kubernetes集群-Skaffold快速迭代本地开发应用"><a href="#Docker-Kubernetes集群-Skaffold快速迭代本地开发应用" class="headerlink" title="Docker+Kubernetes集群+Skaffold快速迭代本地开发应用"></a>Docker+Kubernetes集群+Skaffold快速迭代本地开发应用</h1><pre><code>现在我们的开发流程都是本地开发完成，然后提交代码到git，然后通过bamboo进行自动部署，但是每次修改代码都是重新启动整个容器，对于测试人员和开发人员来说都是对时间的极大浪费，虽然现在使用pass平台，部署的docker应用，但是效率来说相对来说还是比较低下。一直在想有没有一种正真意义上的运维方式，修改代码之后不需要重新启动整个容器，类似于文件同步的那种，修改之后的代码只要提交之后就能够立即生效的。最近几年docker一直很火，而我在自学大数据的过程中，由于自己太懒，不想手动去搭建本地的Hadoop，Hbase,Hive，Spark等等之类的环境，于是，我选择了docker,虽然对与docker也是一知半解，没有深入去了解，但是用了一段时间之后，就发现，容器技术为什么这么火。只需要几个简单的命令，然后从dockerHub上拉取个镜像，然后启动，就能够完整的搭建本地开发环境，而且对于集群环境的搭建也是轻而易举，不得不感叹，我们都落伍了。就在几天前，我遇到了Skaffold，它是一款命令行工具，旨在促进kubernetes应用的持续开发，Skaffold可以将构建、推送及向kubernetes集群部署应用程序的过程自动化，听上去是不是很舒服呀~~~于是好奇的我打算亲自动手试试。</code></pre><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><pre><code>Skaffold是一款命令行工具，旨在促进Kubernetes应用的持续开发。你可以在本地迭代应用源码，然后将其部署到本地或者远程Kubernetes集群中。Skaffold会处理构建、上传和应用部署方面的工作流。它通用可以在自动化环境中使用，例如CI/CD流水线，以实施同样的工作流，并作为将应用迁移到生产环境时的工具 —— Skaffold官方文档</code></pre><p>Skaffold的特点：</p><ul><li>没有服务器端组件，所以不会增加你的集群开销</li><li>自动检测源代码中的更改并自动构建/推送/部署</li><li>自动更新镜像TAG，不要担心手动去更改kubernetes的 manifest 文件</li><li>一次性构建/部署/上传不同的应用，因此它对于微服务同样完美适配</li><li>支持开发环境和生产环境，通过仅一次运行manifest，或者持续观察变更</li></ul><p>另外Skaffold是一个可插拔的架构，允许开发人员选择自己最合适的工作流工具</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>要使用Skaffold最好是提前在我们本地安装一套单节点的kubernetes集群，比如minikube或者Docker for MAC/Windows的Edge版</p><p>我的本地环境MacOS10.13.3+Docker-18.03.0-ce。</p><h4 id="skaffold的安装（MAC版的，Linux版的大家请自行谷歌）"><a href="#skaffold的安装（MAC版的，Linux版的大家请自行谷歌）" class="headerlink" title="skaffold的安装（MAC版的，Linux版的大家请自行谷歌）"></a>skaffold的安装（MAC版的，Linux版的大家请自行谷歌）</h4><p>通过命令行工具，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/latest/skaffold-darwin-amd64 &amp;&amp; chmod +x skaffold &amp;&amp; sudo mv skaffold /usr/local/bin</span><br></pre></td></tr></table></figure><p>当然如果由于某些原因你不能访问上面的链接的话，则可以前往Skaffold的github release页面下载相应的安装包。</p><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>我们可以在本地开发一个非常简单的应用程序，然后通过Skaffold来进行迭代开发，这里我们直接使用Skaffold的官方示例，首先clone代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/GoogleCloudPlatform/skaffold</span><br></pre></td></tr></table></figure><p>然后我们定位到examples/getting-started目录下去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cd skaffold/examples/getting-started                          </span><br><span class="line">$ tree                                                          </span><br><span class="line">.</span><br><span class="line">|____skaffold-gcb.yaml</span><br><span class="line">|____Dockerfile</span><br><span class="line">|____k8s-pod.yaml</span><br><span class="line">|____skaffold.yaml</span><br><span class="line">|____main.go</span><br></pre></td></tr></table></figure><p>该目录下面有一个非常简单的golang程序:（main.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello world!"</span>)</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中skaffold-gcb.yaml文件我们可以暂时忽略，这个文件是和google cloud结合使用的，我们可以看下skaffold.yaml文件内容，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: skaffold/v1alpha2</span><br><span class="line">kind: Config</span><br><span class="line">build:</span><br><span class="line">  artifacts:</span><br><span class="line">  - imageName: gcr.io/k8s-skaffold/skaffold-example</span><br><span class="line">    workspace: .</span><br><span class="line">  local: &#123;&#125;</span><br><span class="line">deploy:</span><br><span class="line">  kubectl:</span><br><span class="line">    manifests:</span><br><span class="line">      - k8s-*</span><br></pre></td></tr></table></figure><p>然后我们可以看到k8s-pod.yaml文件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: getting-started</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: getting-started</span><br><span class="line">    image: gcr.io/k8s-skaffold/skaffold-example</span><br></pre></td></tr></table></figure><p>然后我们就可以在getting-started目录下面执行skaffold dev命令了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">skaffold dev                                           </span><br><span class="line">Starting build...</span><br><span class="line">Found [docker-for-desktop] context, using local docker daemon.</span><br><span class="line">Sending build context to Docker daemon  6.144kB</span><br><span class="line">Step 1/5 : FROM golang:1.9.4-alpine3.7</span><br><span class="line">1.9.4-alpine3.7: Pulling from library/golang</span><br><span class="line">ff3a5c916c92: Already exists</span><br><span class="line">f32d2ea73378: Already exists</span><br><span class="line">7e338747c3ca: Already exists</span><br><span class="line">3a75aa9cb0c3: Pulling fs layer</span><br><span class="line">7a7cfbabfc25: Pulling fs layer</span><br><span class="line">43b7df8cdce7: Pulling fs layer</span><br><span class="line">7a7cfbabfc25: Download complete</span><br><span class="line">43b7df8cdce7: Verifying Checksum</span><br><span class="line">43b7df8cdce7: Download complete</span><br><span class="line">3a75aa9cb0c3: Verifying Checksum</span><br><span class="line">3a75aa9cb0c3: Download complete</span><br><span class="line">3a75aa9cb0c3: Pull complete</span><br><span class="line">7a7cfbabfc25: Pull complete</span><br><span class="line">43b7df8cdce7: Pull complete</span><br><span class="line">Digest: sha256:566ec2d92f3f2ac0a83b941bacff33a2d3a7d98eddcbc288ada912be969cd5aa</span><br><span class="line">Status: Downloaded newer image for golang:1.9.4-alpine3.7</span><br><span class="line"> ---&gt; fb6e10bf973b</span><br><span class="line">Step 2/5 : WORKDIR /go/src/github.com/GoogleCloudPlatform/skaffold/examples/getting-started</span><br><span class="line"> ---&gt; 8f1eabcc41a2</span><br><span class="line">Step 3/5 : CMD [&quot;./app&quot;]</span><br><span class="line"> ---&gt; Running in 2e3279a84ada</span><br><span class="line"> ---&gt; 8c65b0140915</span><br><span class="line">Step 4/5 : COPY main.go .</span><br><span class="line"> ---&gt; 420036b19bd0</span><br><span class="line">Step 5/5 : RUN go build -o app main.go</span><br><span class="line"> ---&gt; Running in 2cd819ac2241</span><br><span class="line"> ---&gt; aec223791bb7</span><br><span class="line">Successfully built aec223791bb7</span><br><span class="line">Successfully tagged 8da0c4f31bfe882ce1117dda832e4f32:latest</span><br><span class="line">Successfully tagged gcr.io/k8s-skaffold/skaffold-example:aec223791bb75362e28fe3aeeac3c7ba9fdf80c0c34b5e8fd068157d8219c277</span><br><span class="line">Build complete in 1m15.696492271s</span><br><span class="line">Starting deploy...</span><br><span class="line">Deploying k8s-pod.yaml...</span><br><span class="line">Deploy complete in 329.744527ms</span><br><span class="line">Watching for changes...</span><br><span class="line">[getting-started] Hello world!</span><br><span class="line">[getting-started] Hello world!</span><br><span class="line">[getting-started] Hello world!</span><br></pre></td></tr></table></figure><p>由于没有安装过golang相关的库，所以有可能会失败，失败之后退出之后重新执行skaffold dev命令就好了，如果尝试多次还不好使，建议使用flowVPN这个翻墙插件，网速让我直接开始怀疑人生。还有个问题就是必须先启动docker，并启动单节点的kubernetes集群。</p><p>Skaffold已经帮我们做了很多事情了：</p><p>用本地源代码构建 Docker 镜像<br>用它的sha256值作为镜像的标签<br>设置skaffold.yaml文件中定义的 kubernetes manifests 的镜像地址<br>用kubectl apply -f命令来部署 kubernetes 应用<br>部署完成后，我们可以看到 pod 打印出了如下的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[getting-started] Hello world!</span><br><span class="line">[getting-started] Hello world!</span><br><span class="line">[getting-started] Hello world!</span><br></pre></td></tr></table></figure><p>现在，我们来更改下我们的main.go文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">fmt.Println(&quot;Hello lyz!&quot;)</span><br><span class="line">time.Sleep(time.Second * 1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们保存该文件后，观察 POD 的输出信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Starting build...</span><br><span class="line">Found [docker-for-desktop] context, using local docker daemon.</span><br><span class="line">Sending build context to Docker daemon  6.144kB</span><br><span class="line">Step 1/5 : FROM golang:1.9.4-alpine3.7</span><br><span class="line"> ---&gt; fb6e10bf973b</span><br><span class="line">Step 2/5 : WORKDIR /go/src/github.com/GoogleCloudPlatform/skaffold/examples/getting-started</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 8f1eabcc41a2</span><br><span class="line">Step 3/5 : CMD [&quot;./app&quot;]</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 8c65b0140915</span><br><span class="line">Step 4/5 : COPY main.go .</span><br><span class="line"> ---&gt; 9fc3e7aaff40</span><br><span class="line">Step 5/5 : RUN go build -o app main.go</span><br><span class="line"> ---&gt; Running in 508b97f29e88</span><br><span class="line"> ---&gt; 811875a31d12</span><br><span class="line">Successfully built 811875a31d12</span><br><span class="line">Successfully tagged 7c393e3a0367411d5e7bec05ae632eb5:latest</span><br><span class="line">Successfully tagged gcr.io/k8s-skaffold/skaffold-example:811875a31d122f07a30dfca0c0058eb44b2c7100b2794a94f9fd52e639e97fff</span><br><span class="line">Build complete in 1.706332689s</span><br><span class="line">Starting deploy...</span><br><span class="line">Deploying k8s-pod.yaml...</span><br><span class="line">Deploy complete in 253.419235ms</span><br><span class="line">Watching for changes...</span><br><span class="line">[getting-started] Hello lyz!</span><br><span class="line">[getting-started] Hello lyz!</span><br><span class="line">[getting-started] Hello lyz!</span><br></pre></td></tr></table></figure><p>修改完文件保存之后，我们没有做任何操作，就看见我们的修改结果，同样我们可以用上面的样式去查看下 POD 里面的镜像标签是已经更改过了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>是不是感觉好神奇的样子，容器跟k8s的自动化让我有点惊讶，虽然对k8s还不是很了解，但是通过今天的操作让我对它充满了兴趣，接下来再慢慢深入。如此自动化的运维开发，相信对于开发和测试的效率会有一个质的提升，真心希望公司也能尽快投入到k8s的环抱～～～</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/GoogleCloudPlatform/skaffold" target="_blank" rel="noopener">https://github.com/GoogleCloudPlatform/skaffold</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker-Kubernetes集群-Skaffold快速迭代本地开发应用&quot;&gt;&lt;a href=&quot;#Docker-Kubernetes集群-Skaffold快速迭代本地开发应用&quot; class=&quot;headerlink&quot; title=&quot;Docker+Kubernete
      
    
    </summary>
    
      <category term="Docker" scheme="http://luyaoze.github.io/categories/Docker/"/>
    
      <category term="Kubernetes" scheme="http://luyaoze.github.io/categories/Docker/Kubernetes/"/>
    
      <category term="Skaffold" scheme="http://luyaoze.github.io/categories/Docker/Kubernetes/Skaffold/"/>
    
    
      <category term="Docker" scheme="http://luyaoze.github.io/tags/Docker/"/>
    
      <category term="运维" scheme="http://luyaoze.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>容器的功能扩展</title>
    <link href="http://luyaoze.github.io/2018/03/30/%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95/"/>
    <id>http://luyaoze.github.io/2018/03/30/容器的功能扩展/</id>
    <published>2018-03-30T13:19:36.000Z</published>
    <updated>2018-03-30T16:11:08.766Z</updated>
    
    <content type="html"><![CDATA[<p><strong>容器的功能扩展</strong></p><hr><ul><li><p>ApplicationContext</p><p>  ApplicationContext和BeanFactory两者都是用于加载Bean的，但是相比之下，ApplicationContext提供更多的扩展功能，简单一点说：ApplicationContext包含BeanFactory的所有功能。通常建议比BeanFactory优先，除非在一些限制的场合，比如字节长度对内存有很大的影响时（Applet）。绝大多数的“典型的”企业应用和系统，ApplicationContext就是你需要使用的。</p><ul><li><p>使用BeanFactory的方式加载XML</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory bf = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">"beanFactoryTrest.xml"</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用ApplicationContent的方式加载XML</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext bf = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beanFactoryTrest.xml"</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><ul><li><p>ClassPathXmlApplicationContext初始化步骤</p><p>  ClassPathXmlApplicationContex是Spring中ApplicationContext接口的默认实现。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）初始化前的准备工作，例如对系统属性或者环境变量进行准备及验证。</p><pre><code>在某种情况下项目的使用需要读取某些系统变量，而这个变量的设置可能会影响着系统的正确性，那么ClassPathXmlApplicationContext为我们提供中的这个准备函数就显得非常必要，它可以在Spring启动的时候提前对必须的变量进行存在性验证。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">initPropertySources();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validate that all properties marked as required are resolvable</span></span><br><span class="line"><span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line"><span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）初始化BeanFactory，并进行XML文件读取。</p><pre><code>由于ClassPathXmlApplicationContext包含着BeanFactory所提供的一切特征，那么在这一步骤中会复用BeanFactory中的配置文件读取解析及其他功能，这一步之后，ClassPathXmlApplicationContext实际上就已经包含了BeanFactory所提供的功能，也就是可以进行Bean的提取等操作了。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">refreshBeanFactory();</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）对BeanFactory进行各种功能填充</p><pre><code>@Qualifier和@Autowired应该是大家非常熟悉的注解，那么这两个注解正是在这一步骤中增加的支持。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Tell the internal bean factory to use the context's class loader etc.</span></span><br><span class="line">beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line"><span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line"><span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register default environment beans.</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）子类覆盖方法做额外的处理。</p><pre><code>Spring之所以强大，为世人所推崇，除了功能上为大家提供了便利外，还有一方面是它的完美架构，开放式的架构让使用它的程序猿很容易根据业务需要扩展已经存在的功能。这种开放式的设计在Spring中随处可见，例如在本例中就提供了一个空的函数实现postProcessBeanFactory来方便程序员在业务上做进一步扩展。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）激活各种Beanfactory处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line"><span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（6）注册拦截bean创建的bean处理器，这里只是注册，真正的调用是在getBean的时候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（7）为上下文初始化Message源，即对不同语言的消息体进行国际化处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line"><span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line"><span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line"><span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line"><span class="comment">// registered already.</span></span><br><span class="line">hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Using MessageSource ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line">dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line"><span class="keyword">this</span>.messageSource = dms;</span><br><span class="line">beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Unable to locate MessageSource with name '"</span> + MESSAGE_SOURCE_BEAN_NAME +</span><br><span class="line"><span class="string">"': using default ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（8）初始化应用消息广播器，并放入“applicationEventMulticaster”bean中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line"><span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Unable to locate ApplicationEventMulticaster with name '"</span> +</span><br><span class="line">APPLICATION_EVENT_MULTICASTER_BEAN_NAME +</span><br><span class="line"><span class="string">"': using default ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（9）留给子类来初始化其他的bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（10）在所有注册的bean中查找listener bean，注册到消息广播器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Register statically specified listeners first.</span></span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（11）初始化剩下的单实例（非惰性的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line"><span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line"><span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> StringValueResolver() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（12）完成刷新过程，通知生命周期处理器lifecycleProcessor刷新过程，同时发出ContenxRefreshEvent通知别人。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish the final event.</span></span><br><span class="line">publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><p>finishRefresh</p><p>  在Spring中还提供了Lifecycle接口，Lifecycle中包含start/stop方法，实现了此接口后Spring会保证在启动的时候调用其start方法开始声明周期，并在Spring关闭的时候调用stop方法来结束生命周期，通常用来配置后台程序，在启动之后一直运行（如对MQ进行轮询等）。而ApplicationContext的初始化最后正是保证了这一功能的实现。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span></span>&#123;</span><br><span class="line">    initLifecycleProcessor();</span><br><span class="line">    getLifecycleProcessor().onRefesh();</span><br><span class="line">    publicEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.initLifecycleProcessor</p><pre><code>当ApplicationContext启动或停止时，它会通过LifecycleProcessor来对所有声明的bean的周期做状态更新，而在LifecycleProcessor的使用前首先需要初始化。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initLifecycleProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"><span class="keyword">this</span>.lifecycleProcessor =</span><br><span class="line">beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Using LifecycleProcessor ["</span> + <span class="keyword">this</span>.lifecycleProcessor + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">DefaultLifecycleProcessor defaultProcessor = <span class="keyword">new</span> DefaultLifecycleProcessor();</span><br><span class="line">defaultProcessor.setBeanFactory(beanFactory);</span><br><span class="line"><span class="keyword">this</span>.lifecycleProcessor = defaultProcessor;</span><br><span class="line">beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, <span class="keyword">this</span>.lifecycleProcessor);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Unable to locate LifecycleProcessor with name '"</span> +</span><br><span class="line">LIFECYCLE_PROCESSOR_BEAN_NAME +</span><br><span class="line"><span class="string">"': using default ["</span> + <span class="keyword">this</span>.lifecycleProcessor + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.onRefresh</p><pre><code>启动所有实现了Lifecycle接口的bean。该方法在ApplicationContext中定义为空方法，需要对应的子类去实现，也正符合Spring面向对象的实现方式。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是实现了Lifecycle接口的bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">startBeans(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">this</span>.running = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBeans</span><span class="params">(<span class="keyword">boolean</span> autoStartupOnly)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();</span><br><span class="line">Map&lt;Integer, LifecycleGroup&gt; phases = <span class="keyword">new</span> HashMap&lt;Integer, LifecycleGroup&gt;();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, ? extends Lifecycle&gt; entry : lifecycleBeans.entrySet()) &#123;</span><br><span class="line">Lifecycle bean = entry.getValue();</span><br><span class="line"><span class="keyword">if</span> (!autoStartupOnly || (bean <span class="keyword">instanceof</span> SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) &#123;</span><br><span class="line"><span class="keyword">int</span> phase = getPhase(bean);</span><br><span class="line">LifecycleGroup group = phases.get(phase);</span><br><span class="line"><span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">group = <span class="keyword">new</span> LifecycleGroup(phase, <span class="keyword">this</span>.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);</span><br><span class="line">phases.put(phase, group);</span><br><span class="line">&#125;</span><br><span class="line">group.add(entry.getKey(), bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!phases.isEmpty()) &#123;</span><br><span class="line">List&lt;Integer&gt; keys = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(phases.keySet());</span><br><span class="line">Collections.sort(keys);</span><br><span class="line"><span class="keyword">for</span> (Integer key : keys) &#123;</span><br><span class="line">phases.get(key).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.publishEvent</p><pre><code>当完成ApplicationContext初始化的时候，要通过Spring中的事件发布机制来发出ContextRefreshEvent事件，以保证对应的监听器可以做进一步的逻辑处理。    </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">publishEvent(event, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;容器的功能扩展&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ApplicationContext&lt;/p&gt;
&lt;p&gt;  ApplicationContext和BeanFactory两者都是用于加载Bean的，但是相比之下，ApplicationC
      
    
    </summary>
    
      <category term="java" scheme="http://luyaoze.github.io/categories/java/"/>
    
      <category term="spring" scheme="http://luyaoze.github.io/categories/java/spring/"/>
    
      <category term="ioc" scheme="http://luyaoze.github.io/categories/java/spring/ioc/"/>
    
    
      <category term="ioc" scheme="http://luyaoze.github.io/tags/ioc/"/>
    
  </entry>
  
  <entry>
    <title>Bean的解析和加载</title>
    <link href="http://luyaoze.github.io/2018/03/29/%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://luyaoze.github.io/2018/03/29/默认标签的解析/</id>
    <published>2018-03-28T16:16:37.000Z</published>
    <updated>2018-03-28T18:57:46.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bean的解析和加载"><a href="#Bean的解析和加载" class="headerlink" title="Bean的解析和加载"></a>Bean的解析和加载</h2><ul><li><p><strong>bean标签的解析和注册</strong></p><p>  （1）首先委托BeanDefinitionDelegate类的parseBeanDefinitionElement方法进行元素解析，返回BeanDefinitionHolder类型的实例bdHolder，经过这个方法之后，bdHolder实例已经包含我们配置文件中配置的各种属性了，例如class、name、id、alias之类的属性了。<br>  （2）当返回bdHolder不为空的情况下若存在默认标签的子节点下再有自定义属性，还需要再次对自定义标签进行解析。<br>  （3）完成解析之后，需要对解析后的bdHolder进行注册，同样，注册操作委托给BeanDefinitionReaderUtils的registerBeanDefinition方法。<br>  （4）最后发出响应事件，通知相关的监听器，这个bean已经加载完成了。</p></li></ul><hr><ul><li><strong>bean的加载</strong></li></ul><p>（1）转换对应的beanName</p><pre><code>去除FactoryBean的修饰符，也就是如果name=&quot;&amp;aa&quot;,name会首先去除&amp;而使name=“aa”。取指定alias所表示的最终beanName，例如别名A指向名称为B的bean则返回B；若别名指向别名B，别名B又指向名称为C的bean则返回C。</code></pre><p>（2）尝试从缓存中加载单例。</p><pre><code>单例在spring的同一容器内只会被创建一次，后续再获取bean，就直接从单例缓存中获取了。当然这里也只是尝试加载，首先尝试从缓存中加载，如果加载不成功则再次尝试从singlentonFactories中加载。因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候避免循环依赖，在spring中创建bean的原则是不等bean创建完成就会将创建bean的ObjectFactory提早曝光加入到缓存中，一旦一下个bean创建的时候就需要依赖上一个bean则直接使用ObjectFactory。</code></pre><p>（3）bean的实例化</p><pre><code>如果从缓存中得到了bean的原始状态，则需要对bean进行实例化。缓存中记录的只是最原始的bean状态，并不一定是我们最终想要的bean。假如我们需要工厂bean进行处理，那么我们这里得到的其实是工厂bean的初始状态，但是我们真正需要的是工厂bean中定义的factory-method方法中返回的bean，而getObjectForBeanInstance就是完成这个工作的。</code></pre><p>（4）原型模式的依赖检查</p><pre><code>只有在单例的情况下才会尝试解决循环依赖，如果存在A中有B的属性，B中有A的属性，那么当依赖注入的时候，就会产生当A还未创建完的时候因为对于B的创建再次返回创建A，造成循环依赖，也就是情况：isPrototypeCurrentlyIncreation(beanName)判断true。</code></pre><p>（5）检测parentBeanFactory</p><p>（6）将存储XML配置文件的GernericBeanDefinition转换为RootBeanDefinition.</p><pre><code>因为XML配置文件中读取到的bean信息是存储在GernericBeanDefinition中的，但是所有的bean后续处理都是针对RootBeanDefinition的，所以这里要进行一个转换，转换的同时如果父类bean不为空的话，则会一并合并父类的属性。</code></pre><p>（7）寻找依赖</p><pre><code>因为bean的初始化过程中很可能会用到某些属性，而某些属性很肯能是动态配置的，并且配置成依赖于其他的bean，那么这个时候就有必要先加载依赖的bean，所以在spring的加载顺序中，在初始化某一个bean的时候都首先会初始化这个bean所对应的依赖。</code></pre><p>（8）针对不同的scope进行bean的创建<br>（9）类型转换</p><hr><ul><li><strong>FactoryBean的使用</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>T getObject():返回由FactoryBean创建的bean实例，如果isSingleton（）返回true，则该实例会放到Spring容器中单例缓存池中。</li><li>boolean isSingleton()：返回由FactoryBean创建的bean实例的作用域是singleton还是prototype。</li><li>Class&lt;?&gt; getObjectType()：返回FactoryBean创建的bean类型。</li></ul><hr><ul><li><p><strong>循环依赖</strong></p><p>  循环依赖就是循环引用，就是两个或多个bean相互之间的持有对方，比如CircleA引用CircleB。CircleB引用CircleC，CircleC引用CircleA，则他们最终反映为一个环。此处不是循环调用，循环调用是方法之间的环调用。循环依赖是无法解决的，除非有最终条件，否则就是死循环，最终导致内存溢出错误。</p></li><li><p>Spring如何解决循环依赖</p><p>  （1）构造器循环依赖</p><pre><code>Spring容器将每一个正在创建的bean标识符放在一个“当前创建bean池”中，bean标识符在创建过程中将一直保持在这个池中，因此如果创建bean过程中发现自己已经在“当前创建bean池”里时，将抛出BeanCurrentlyCreationException异常表示循环依赖；而对于创建完毕的bean将从“当前创建bean池”中清楚掉。</code></pre><p>  （2）setter循环依赖</p><pre><code>表示对于setter注入造成的循环依赖是通过Spring容器提前暴露刚完成构造器注入但未完成其他步骤（如setter注入）的bean来完成的，而且只能解决单例作用域的bean循环依赖。通过暴露一个单例工厂方法，从而使其他bean能引用到该bean。</code></pre><p>  （3）prototype范围的依赖处理</p><pre><code>对于“prototype“作用域bean，Spring容器无法完成依赖注入，因为Spring容器不进行缓存”prototype“作用域的bean，因此无法提前暴露一个创建中的bean。</code></pre></li></ul><hr><ul><li><p><strong>创建bean</strong></p><p>  （1）如果是单例则需要首先清楚缓存。</p><p>  （2）实例化bean，将BeanDefinition转换为BeanWrapper。</p><pre><code>* 如果存在工厂方法则使用工厂方法进行初始化* 一个类有多个构造函数，每个构造函数都有不同的参数，所以要根据参数锁定构造函数进行初始化。* 如果既不存在工厂方法也不存在带有参数的构造函数，则使用默认的构造函数进行bean的实例化。</code></pre><p>  （3）MergerBeanDefinitionPostProcessor的应用</p><pre><code>bean合并处理后，Autowired注解正是通过此方法实现诸如类型的预解析。</code></pre><p>  （4）依赖处理</p><p>  （5）属性填充</p><p>  （6）循环依赖检查</p><p>  （7）注册DisposableBean</p><pre><code>如果配置了destroy-method，这里需要注册以便于在销毁时调用。</code></pre><p>  （8）完成创建并返回。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Bean的解析和加载&quot;&gt;&lt;a href=&quot;#Bean的解析和加载&quot; class=&quot;headerlink&quot; title=&quot;Bean的解析和加载&quot;&gt;&lt;/a&gt;Bean的解析和加载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;bean标签的解析和注册&lt;/strong&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://luyaoze.github.io/categories/java/"/>
    
    
      <category term="spring" scheme="http://luyaoze.github.io/tags/spring/"/>
    
      <category term="ioc" scheme="http://luyaoze.github.io/tags/ioc/"/>
    
      <category term="bean" scheme="http://luyaoze.github.io/tags/bean/"/>
    
  </entry>
  
  <entry>
    <title>XML的验证模式</title>
    <link href="http://luyaoze.github.io/2018/03/27/XML%E7%9A%84%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://luyaoze.github.io/2018/03/27/XML的验证模式/</id>
    <published>2018-03-26T16:31:10.000Z</published>
    <updated>2018-03-28T18:06:16.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="xml的验证模式"><a href="#xml的验证模式" class="headerlink" title="xml的验证模式"></a>xml的验证模式</h2><ul><li><strong>DTD与XSD区别</strong></li></ul><hr><p>DTD即文档类型定义，是一种XML约束模式语言，是XML文件的验证机制，属于XML文件组成的一部分。DTD是一种保证XML文档格式正确的有效方法，可以通过比较XML文档和DTD文件来看文档是否符合规范，语速和标签使用是否正确。一个DTD文档包含：元素的定义规则，元素间关系的定义规则，元素可使用的属性，可使用的实体或者符号规则。<br>XML Schema语言就是XSD。XML Schema描述文档的结构。可以使用一个指定的XML Schema来验证某个XML文档，以检查该XML文档所允许的结构和内容，并可据检查一个XML文档是否是有效的。XML Schema本身是一个XML文档，它符合XML语法结构。可以通过通用的XML解析器解析它。</p><ul><li><strong>获取Document</strong></li></ul><hr><p>经过验证模式准备的步骤就可以进行Document加载了，同样XmlBeanFactoryReader类对于文档读取并没有亲力亲为，而是委托给DocumentLoader去执行，这里的DocumentLoader是个接口，而真正调用的是DefaultDocumentLoader。</p><ul><li><strong>EntityResolver</strong></li></ul><hr><p>官网解释：如果SAX应用程序需要实现自定义的处理外部实体部分，则必须实现此接口并使用setEntityResolver方法向SAX驱动器注册一个实例。也就是说，对于解析一个XML，SAX首先读取该文档上的声明，根据声明去寻找相对应的DTD定义，以便对文档进行一个验证。默认的寻找规则，即通过网络来下载，并进行验证。<br>EntityResolver的作用是项目本身就可以提供一个如何寻找DTD声明的方法，即由程序来实现寻找DTD声明的过程，比如我们将DTD文件放到项目中某处，在实现时直接将此文档读取并返回SAX即可。这样就避免了通过网络来寻找相应的声明。<br>对于不同的验证模式，Spring使用了不同的解析器进行解析。加载DTD类型的BeansDtdResolver类的resolverEntity是直接街区systemId最后的xx.dtd然后去当前路径下寻找，而加载XSD类型的PluggableSchemaResolver类的resolveEntity是默认到META-INF/Spring.schemas文件中找到systemId所对应的XSD文件进行加载。</p><ul><li><strong>解析及注册BeanDefinitions</strong></li></ul><hr><p>把文件转换为Document后，接下来就是加载。如果需要在加载前后做其他的事情，只需要继承DefaultBeanDefinitionDocymentReader然后重写preProcessXml(root)或者postProcessXml(root)这两个方法。默认的实现这两个方法是空着的，但是，这里使用模板方法模式进行设计，方便后续的扩展。就像面向对象的方法学中常说的一句话，一个类要么是面向继承的设计的，要么就用final修饰。</p><ul><li><strong>profile属性的使用</strong></li></ul><hr><p>注册bean的最开始是对PAOFILE_ATTRIBUTE属性的解析。在web环境中可以在web.xml当中配置Spring.profile.active，有了这个属性就可以方便的进行切换环境，常用的就是切换数据源。<br>对于Bean的申明，一种是默认的XML格式，另一种就是注解模式。</p><ul><li><strong>解析各种属性</strong></li></ul><hr><p>scope–&gt;singleton–&gt;abstract–&gt;lazy-init(如果没有设置或设置成其他字符都会被设置为false)–&gt;autowire–&gt;dependency-check–&gt;depends-on–&gt;autowire-candidate–&gt;primary–&gt;init-method–&gt;destory-method–&gt;factory-method–&gt;factory-bean.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;xml的验证模式&quot;&gt;&lt;a href=&quot;#xml的验证模式&quot; class=&quot;headerlink&quot; title=&quot;xml的验证模式&quot;&gt;&lt;/a&gt;xml的验证模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DTD与XSD区别&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h
      
    
    </summary>
    
      <category term="java" scheme="http://luyaoze.github.io/categories/java/"/>
    
    
      <category term="spring" scheme="http://luyaoze.github.io/tags/spring/"/>
    
      <category term="xml" scheme="http://luyaoze.github.io/tags/xml/"/>
    
  </entry>
  
  <entry>
    <title>IOC（一）</title>
    <link href="http://luyaoze.github.io/2018/03/25/IOC%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://luyaoze.github.io/2018/03/25/IOC（一）/</id>
    <published>2018-03-25T14:07:01.000Z</published>
    <updated>2018-03-28T18:05:53.896Z</updated>
    
    <content type="html"><![CDATA[<p>Spring源码学习（一）</p><h2 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a>DefaultListableBeanFactory</h2><ul><li><strong>DefaultListableBeanFactory</strong>是spring整个bean加载的核心部分，是spring注册及加载bean的默认实现。XmlBeanFactory继承了自DefaultListableBeanFactory，不同的就是XmlBeanFactory中使用了自定义的XmlBeanDefinitionReader，实现了自定义的BeanDefinitionReader读取。</li><li><p><strong>AliasRegistry</strong> - 定义对alias的简单的增删改操作。spring-core模块下的接口.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void registerAlias(String name, String alias);</span><br><span class="line">void removeAlias(String alias);</span><br><span class="line">boolean isAlias(String name);</span><br><span class="line">String[] getAliases(String name);</span><br></pre></td></tr></table></figure></li><li><p><strong>SimpleAliasRegistry</strong> - 使用map作为缓存，对AliasRegistry接口进行实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;String, String&gt; aliasMap = new ConcurrentHashMap(16);</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>SingLetonBeanRegistry</strong> - 定义对单例的注册及获取</li><li><strong>BeanFactory</strong> -定义获取bean及bean的各种属性</li><li><strong>DefaultSingletonBeanRegistry</strong> -继承SimpleAliasRegistry 实现SingletonBeanRegistry接口。</li><li><strong>HierarchicalBeanFactory</strong> -继承自BeanFactory，也就是在BeanFactory的基础上增加了对parentFactory的支持。</li><li><strong>BeanDefinitionRegistry</strong> -继承自AliasRegistry，定义对BeanDefinition的各种增删改操作，默认的实现为DefaultListableBeanFactory。</li><li><strong>FactoryBeanRegistrySupport</strong> -继承自DefaultSingletonBeanRegistry，在原有的基础上增加了对FactoryBean的特殊处理功能。</li><li><strong>ConfigurableBeanFactory</strong> -继承了HierarchicalBeanFactory和SingletonBeanRegistry两个接口，提供配置Factory的各种方法。</li><li><strong>ListableBeanFactory</strong> -继承了BeanFactory，提供各种条件获取bean的配置清单。</li><li><strong>AbstractBeanFactory</strong> -抽象类，继承了FactoryBeanRegistrySupport，实现了ConfigurableBeanFactory接口，对两者的功能进行整合。</li><li><strong>AutowireCapableBeanFactory</strong> -继承自BeanFactory，提供创建bean、自动注入、初始化以及应用bean的后处理器。</li><li><strong>AutowireCapableBeanFactory</strong> -继承了AbstractBeanFactory，实现了AutowireCapableBeanFactory接口。</li><li><strong>ConfigurableListableBeanFactory</strong> -继承了ListableBeanFactory，AutowireCapableBeanFactory，ConfigurableBeanFactory三个接口，beanFactory的配置清单，制定忽略类型及接口等。</li><li><strong>DefaultListableBeanFactory</strong> -综合上面所有的功能，主要是对bean注册后的处理。</li><li><strong>XmlBeanFactory</strong> 对DefaultListableBeanFactory类进行了拓展，主要用于从XML文档中读取BeanDefinition，对于注册Bean都是从父类DefaultListableBeanFactory继承的方法去实现，而唯独与父类不同的的个性化实现就是增加了XmlBeanDefinitionReader类型的reader属性。在XmlBeanFactory中主要使用reader属性对资源进行读取和注册。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring源码学习（一）&lt;/p&gt;
&lt;h2 id=&quot;DefaultListableBeanFactory&quot;&gt;&lt;a href=&quot;#DefaultListableBeanFactory&quot; class=&quot;headerlink&quot; title=&quot;DefaultListableBean
      
    
    </summary>
    
      <category term="java" scheme="http://luyaoze.github.io/categories/java/"/>
    
    
      <category term="spring" scheme="http://luyaoze.github.io/tags/spring/"/>
    
      <category term="ioc" scheme="http://luyaoze.github.io/tags/ioc/"/>
    
  </entry>
  
</feed>
