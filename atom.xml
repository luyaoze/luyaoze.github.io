<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyz的博客</title>
  
  <subtitle>静静地搬砖</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luyaoze.github.io/"/>
  <updated>2018-04-02T16:33:21.148Z</updated>
  <id>http://luyaoze.github.io/</id>
  
  <author>
    <name>卢耀泽</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AOP</title>
    <link href="http://luyaoze.github.io/2018/04/02/AOP/"/>
    <id>http://luyaoze.github.io/2018/04/02/AOP/</id>
    <published>2018-04-02T14:02:59.000Z</published>
    <updated>2018-04-02T16:33:21.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><pre><code>我们知道，使用面向对象编程（OOP）有一些弊端，当需要为多个不具有及继承关系的对象引入同一个公共行为时，例如日志、安全检测等，我们只有在每个对象里引用公共行为，这样程序中就产生了大量的重复代码，程序就不便于维护了，所以就有了一个，面向对象编程的补充，即面向切面编程（AOP），AOP所关注的方向时横向的，不同于OOP的纵向。使用@AspectJ注解对POJO进行标注，使用AspectJ切点表达式语法进行切点定义，可以通过切点函数、运算符、通配符等高级功能进行切点定义，拥有强大的连接点描述能力。</code></pre><h2 id="动态AOP使用示例"><a href="#动态AOP使用示例" class="headerlink" title="动态AOP使用示例"></a>动态AOP使用示例</h2><pre><code>（1）创建用于拦截的bean在实际工作中，此bean可能满足业务需要的核心逻辑，例如test方法中可能会封装着某个核心业务，但是，如果我们想在test前后加入日志来跟踪调试，如果直接修改源码并不符合面向对戏那个的设计方法，而且随意改动原有代码也会造成一定的风险，还好接下来的Spring帮我们做到了这一点。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String testStr = <span class="string">"testStr"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTestStr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testStr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestStr</span><span class="params">(String testStr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testStr = testStr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>(2)创建Advisor。Spring中摒弃了最原始的繁杂配置方式而采用@AspectJ注解对POJO进行标注，使AOP的工作大大简化，例如，在AspectJTest类中，我们要做的就是在所有类的test方法执行前在控制台中打印beforeTest，而在所有类的test方法执行后打印afterTest，同时又使用环绕的方式在所有类的方法执行前后再次分别打印before1和after1.</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsoectJTest</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义切点</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* *.test(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"test()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"beforeTest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"test()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"afterTest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"test()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundTest</span><span class="params">(ProceedingJoinPoint p)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before1"</span>);</span><br><span class="line">        Object o = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            o = p.proceed();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after1"</span>);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>(3)创建配置文件XML是Spring的基础，尽管Spring配置一再简化，并且大有使用注解取代XML配置之势，但是无论如何，至少现在XML还是Spring的基础。要在Spring中开启AOP够功能，还需要在Spring配置文件中声明&lt;aop:aspectj-autoproxy /&gt;。</code></pre><h2 id="AOP标签属性"><a href="#AOP标签属性" class="headerlink" title="AOP标签属性"></a>AOP标签属性</h2><ul><li><p>proxy-target-class和expose-proxy</p><p>  （1）proxy-target-class</p><p>  SpringAOP部分使用JDK动态代理或者CGLIB来为目标对象创建代理。（建议尽量使用JDK动态代理），如果被代理的目标对象实现了至少一个接口，则会使用JDK动态代理。所有该目标类型实现的接口都将被代理。若该目标对象没有实现任何接口，则创建一个CGLIB代理。如果你希望强制使用CGLIB代理，（例如希望代理目标对象的所有方法，而不是实现自接口的方法）那也可以，但是需要考虑一下两个问题。</p><ul><li>无法通知（advise）Final方法，因为他们不能被重写。</li><li><p>你需要将CGLIB二进制发行包放在classpath下面。</p><p>相比较而言吗，JDK本身就提供了动态代理，强制使用CGLIB代理需要将aop:config的proxy-target-class属性设为true。</p><p>当需要使用CGLIB代理和@AspectJ自动代理支持，需要设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;&gt;...&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>* JDK动态代理：其代理对象必须是某个接口的实现，它是通过在运行期间内创建一个接口来实现对目标对目标对象的代理。* CGLIB代理：实现原理类似于JDK动态代理，只是它在运行期间生成的代理对象是针对目标类拓展的子类。CGLIB是高效的代码生成包，底层是依靠ASM（开源的Java字节码编辑类库）操作字节码实现的，性能比JDK强。* expose-proxy：有时候目标对象内部的自我调用将无法实施切面中的增强，如下实例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServiceImpl</span> <span class="keyword">implements</span> <span class="title">AService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> vlid <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>此处的this指向目标对象，因此调用this.b（）将不会执行b事物切面，即不会执行事务增强，因此b方法的事务定义“@Transactional(propagation = Propagation.REQUIRES_NEW)”将不会执行，为了解决这个问题，我们可以这样做</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy expose-proxy=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure><pre><code>然后将以上代码中的“this.b();”修改为“((AService)AopContext.currentProxy()).b();”即可。通过以上的修改便可以完成对a和b方法的同时增强。最后注册组件并通知，便于监听器做进一步处理。</code></pre><h2 id="静态AOP使用示例"><a href="#静态AOP使用示例" class="headerlink" title="静态AOP使用示例"></a>静态AOP使用示例</h2><pre><code>加载时织入（Load-Time Weaving,LTW）指的是在虚拟机载入字节码文件时动态织入AspectJ切面。Spring框架的值添加为AspectJ LTW在动态织入的过程中提供了更细粒度的控制。使用Java（5+）的代理能使用一个叫“Vanilla”的AspectJ LTW，这需要在启动jvm的时候将某个JVM参数设置为开。这种JVM范围的设置在一些情况下或许不错，但通常情况下显得又些粗颗粒。而用Spring的LTW能让你在per-ClassLoader的基础上打开LTW，这显然更加细粒度并且对“单JVM多应用”的环境更具意义（例如在一个典型应用服务器环境中）。另外，在-javaagent:path/to/aspectjweaver.jar或者-javaagent:path/to/Spring-agent.jar。开发人员只需要简单修改应用上下文的一个或几个文件就能使用LTW，而不需要依靠哪些管理者部署配置。我们还是以之前的AOP实例为基础，如果想从动态代理的方式改成静态代理的方式需要做如下改动。（1）Spring全局配置文件的修改，加入LWT开关。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:load-time-weaver /&gt;</span><br></pre></td></tr></table></figure><pre><code>(2)加入aop.xml。在class目录下的META-INF（没有则自己建立）文件夹下建立aop.xml，内容如下：</code></pre><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE aspectj PUBLIC "-//AspectJ//DTD//EN" "http://www.eclipes.org/aspecjt/dtd/aspectj.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aspectj</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">weaver</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">within</span>=<span class="string">"test.*"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">weaver</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">aspects</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"test.AspectJTest"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aspects</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aspectj</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--主要是告诉AspectJ需要对哪个包进行织入，并使用哪些增强器。--&gt;</span></span><br></pre></td></tr></table></figure><pre><code>（3）加入启动参数。如果是Eclipse中启动需要加上启动参数， </code></pre><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:e:\org.springframework.instrument.jar</span><br></pre></td></tr></table></figure><pre><code>结果跟动态AOP并无差别。静态代理主要是在虚拟机启动的时候通过改变目标对象字节码的方式来完成对目标对象的增强，它与动态代理相比具有更高的效率，因为动态代理调用的过程中，还需要一个动态创建代理类并对代理目标对象的步骤，而静态代理则是在启动时便完成了字节码增强当系统再次调用目标类时与调用正常的类并无差别，所以在效率上会相对高些。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AOP&quot;&gt;&lt;a href=&quot;#AOP&quot; class=&quot;headerlink&quot; title=&quot;AOP&quot;&gt;&lt;/a&gt;AOP&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;我们知道，使用面向对象编程（OOP）有一些弊端，当需要为多个不具有及继承关系的对象引入同一个公共行为时，例如日志、安
      
    
    </summary>
    
      <category term="java" scheme="http://luyaoze.github.io/categories/java/"/>
    
      <category term="spring" scheme="http://luyaoze.github.io/categories/java/spring/"/>
    
      <category term="aop" scheme="http://luyaoze.github.io/categories/java/spring/aop/"/>
    
    
      <category term="aop" scheme="http://luyaoze.github.io/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>Docker+Kubernetes集群+Skaffold快速迭代本地开发应用</title>
    <link href="http://luyaoze.github.io/2018/04/01/Docker-Kubernetes%E9%9B%86%E7%BE%A4-Skaffold%E5%BF%AB%E9%80%9F%E8%BF%AD%E4%BB%A3%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/"/>
    <id>http://luyaoze.github.io/2018/04/01/Docker-Kubernetes集群-Skaffold快速迭代本地开发应用/</id>
    <published>2018-04-01T13:47:59.000Z</published>
    <updated>2018-04-01T17:48:01.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-Kubernetes集群-Skaffold快速迭代本地开发应用"><a href="#Docker-Kubernetes集群-Skaffold快速迭代本地开发应用" class="headerlink" title="Docker+Kubernetes集群+Skaffold快速迭代本地开发应用"></a>Docker+Kubernetes集群+Skaffold快速迭代本地开发应用</h1><pre><code>现在我们的开发流程都是本地开发完成，然后提交代码到git，然后通过bamboo进行自动部署，但是每次修改代码都是重新启动整个容器，对于测试人员和开发人员来说都是对时间的极大浪费，虽然现在使用pass平台，部署的docker应用，但是效率来说相对来说还是比较低下。一直在想有没有一种正真意义上的运维方式，修改代码之后不需要重新启动整个容器，类似于文件同步的那种，修改之后的代码只要提交之后就能够立即生效的。最近几年docker一直很火，而我在自学大数据的过程中，由于自己太懒，不想手动去搭建本地的Hadoop，Hbase,Hive，Spark等等之类的环境，于是，我选择了docker,虽然对与docker也是一知半解，没有深入去了解，但是用了一段时间之后，就发现，容器技术为什么这么火。只需要几个简单的命令，然后从dockerHub上拉取个镜像，然后启动，就能够完整的搭建本地开发环境，而且对于集群环境的搭建也是轻而易举，不得不感叹，我们都落伍了。就在几天前，我遇到了Skaffold，它是一款命令行工具，旨在促进kubernetes应用的持续开发，Skaffold可以将构建、推送及向kubernetes集群部署应用程序的过程自动化，听上去是不是很舒服呀~~~于是好奇的我打算亲自动手试试。</code></pre><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><pre><code>Skaffold是一款命令行工具，旨在促进Kubernetes应用的持续开发。你可以在本地迭代应用源码，然后将其部署到本地或者远程Kubernetes集群中。Skaffold会处理构建、上传和应用部署方面的工作流。它通用可以在自动化环境中使用，例如CI/CD流水线，以实施同样的工作流，并作为将应用迁移到生产环境时的工具 —— Skaffold官方文档</code></pre><p>Skaffold的特点：</p><ul><li>没有服务器端组件，所以不会增加你的集群开销</li><li>自动检测源代码中的更改并自动构建/推送/部署</li><li>自动更新镜像TAG，不要担心手动去更改kubernetes的 manifest 文件</li><li>一次性构建/部署/上传不同的应用，因此它对于微服务同样完美适配</li><li>支持开发环境和生产环境，通过仅一次运行manifest，或者持续观察变更</li></ul><p>另外Skaffold是一个可插拔的架构，允许开发人员选择自己最合适的工作流工具</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>要使用Skaffold最好是提前在我们本地安装一套单节点的kubernetes集群，比如minikube或者Docker for MAC/Windows的Edge版</p><p>我的本地环境MacOS10.13.3+Docker-18.03.0-ce。</p><h4 id="1-skaffold的安装（MAC版的，Linux版的大家请自行谷歌）"><a href="#1-skaffold的安装（MAC版的，Linux版的大家请自行谷歌）" class="headerlink" title="1.skaffold的安装（MAC版的，Linux版的大家请自行谷歌）"></a>1.skaffold的安装（MAC版的，Linux版的大家请自行谷歌）</h4><p>通过命令行工具，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/latest/skaffold-darwin-amd64 &amp;&amp; chmod +x skaffold &amp;&amp; sudo mv skaffold /usr/local/bin</span><br></pre></td></tr></table></figure><p>当然如果由于某些原因你不能访问上面的链接的话，则可以前往Skaffold的github release页面下载相应的安装包。</p><h4 id="2-Kubernetes集群"><a href="#2-Kubernetes集群" class="headerlink" title="2.Kubernetes集群"></a>2.Kubernetes集群</h4><p>为了简单起见，我使用的是Docker for Mac（Edge）自带的单节点的Kubernetes集群，至于这个的安装，大家谷歌一下，安装的时候建议翻墙，我的MAC上使用的翻墙软件为VPN Plus，因为这个是免费的，而且相对比较稳定，不翻墙的话Kubernetes的有些镜像可能下载会失败。</p><h4 id="3-kubectl"><a href="#3-kubectl" class="headerlink" title="3.kubectl"></a>3.kubectl</h4><p>要使用kubernetes那么肯定kubectl也是少不了的，在本地配置上你的目标群集的当前上下文进行开发，这个也是跟docker一起安装的。</p><h4 id="4-Docker"><a href="#4-Docker" class="headerlink" title="4.Docker"></a>4.Docker</h4><p>这个不是今天的重点，自行谷歌。</p><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>我们可以在本地开发一个非常简单的应用程序，然后通过Skaffold来进行迭代开发，这里我们直接使用Skaffold的官方示例，首先clone代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/GoogleCloudPlatform/skaffold</span><br></pre></td></tr></table></figure><p>然后我们定位到examples/getting-started目录下去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cd skaffold/examples/getting-started                          </span><br><span class="line">$ tree                                                          </span><br><span class="line">.</span><br><span class="line">|____skaffold-gcb.yaml</span><br><span class="line">|____Dockerfile</span><br><span class="line">|____k8s-pod.yaml</span><br><span class="line">|____skaffold.yaml</span><br><span class="line">|____main.go</span><br></pre></td></tr></table></figure><p>该目录下面有一个非常简单的golang程序:（main.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello world!"</span>)</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中skaffold-gcb.yaml文件我们可以暂时忽略，这个文件是和google cloud结合使用的，我们可以看下skaffold.yaml文件内容，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: skaffold/v1alpha2</span><br><span class="line">kind: Config</span><br><span class="line">build:</span><br><span class="line">  artifacts:</span><br><span class="line">  - imageName: gcr.io/k8s-skaffold/skaffold-example</span><br><span class="line">    workspace: .</span><br><span class="line">  local: &#123;&#125;</span><br><span class="line">deploy:</span><br><span class="line">  kubectl:</span><br><span class="line">    manifests:</span><br><span class="line">      - k8s-*</span><br></pre></td></tr></table></figure><p>然后我们可以看到k8s-pod.yaml文件，修改image的参数为IMAGE_NAME，这个地方Skaffold会自动帮我们替换成正在的镜像地址的，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: getting-started</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: getting-started</span><br><span class="line">    image: gcr.io/k8s-skaffold/skaffold-example</span><br></pre></td></tr></table></figure><p>然后我们就可以在getting-started目录下面执行skaffold dev命令了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">skaffold dev                                           </span><br><span class="line">Starting build...</span><br><span class="line">Found [docker-for-desktop] context, using local docker daemon.</span><br><span class="line">Sending build context to Docker daemon  6.144kB</span><br><span class="line">Step 1/5 : FROM golang:1.9.4-alpine3.7</span><br><span class="line">1.9.4-alpine3.7: Pulling from library/golang</span><br><span class="line">ff3a5c916c92: Already exists</span><br><span class="line">f32d2ea73378: Already exists</span><br><span class="line">7e338747c3ca: Already exists</span><br><span class="line">3a75aa9cb0c3: Pulling fs layer</span><br><span class="line">7a7cfbabfc25: Pulling fs layer</span><br><span class="line">43b7df8cdce7: Pulling fs layer</span><br><span class="line">7a7cfbabfc25: Download complete</span><br><span class="line">43b7df8cdce7: Verifying Checksum</span><br><span class="line">43b7df8cdce7: Download complete</span><br><span class="line">3a75aa9cb0c3: Verifying Checksum</span><br><span class="line">3a75aa9cb0c3: Download complete</span><br><span class="line">3a75aa9cb0c3: Pull complete</span><br><span class="line">7a7cfbabfc25: Pull complete</span><br><span class="line">43b7df8cdce7: Pull complete</span><br><span class="line">Digest: sha256:566ec2d92f3f2ac0a83b941bacff33a2d3a7d98eddcbc288ada912be969cd5aa</span><br><span class="line">Status: Downloaded newer image for golang:1.9.4-alpine3.7</span><br><span class="line"> ---&gt; fb6e10bf973b</span><br><span class="line">Step 2/5 : WORKDIR /go/src/github.com/GoogleCloudPlatform/skaffold/examples/getting-started</span><br><span class="line"> ---&gt; 8f1eabcc41a2</span><br><span class="line">Step 3/5 : CMD [&quot;./app&quot;]</span><br><span class="line"> ---&gt; Running in 2e3279a84ada</span><br><span class="line"> ---&gt; 8c65b0140915</span><br><span class="line">Step 4/5 : COPY main.go .</span><br><span class="line"> ---&gt; 420036b19bd0</span><br><span class="line">Step 5/5 : RUN go build -o app main.go</span><br><span class="line"> ---&gt; Running in 2cd819ac2241</span><br><span class="line"> ---&gt; aec223791bb7</span><br><span class="line">Successfully built aec223791bb7</span><br><span class="line">Successfully tagged 8da0c4f31bfe882ce1117dda832e4f32:latest</span><br><span class="line">Successfully tagged gcr.io/k8s-skaffold/skaffold-example:aec223791bb75362e28fe3aeeac3c7ba9fdf80c0c34b5e8fd068157d8219c277</span><br><span class="line">Build complete in 1m15.696492271s</span><br><span class="line">Starting deploy...</span><br><span class="line">Deploying k8s-pod.yaml...</span><br><span class="line">Deploy complete in 329.744527ms</span><br><span class="line">Watching for changes...</span><br><span class="line">[getting-started] Hello world!</span><br><span class="line">[getting-started] Hello world!</span><br><span class="line">[getting-started] Hello world!</span><br></pre></td></tr></table></figure><p>由于没有安装过golang相关的苦，所以有可能会失败，失败之后退出之后重新执行skaffold dev命令就好了，如果尝试多次还不好使，建议使用flowVPN这个翻墙插件，网速让我直接开始怀疑人生。</p><p>Skaffold已经帮我们做了很多事情了：</p><p>用本地源代码构建 Docker 镜像<br>用它的sha256值作为镜像的标签<br>设置skaffold.yaml文件中定义的 kubernetes manifests 的镜像地址<br>用kubectl apply -f命令来部署 kubernetes 应用<br>部署完成后，我们可以看到 pod 打印出了如下的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[getting-started] Hello world!</span><br><span class="line">[getting-started] Hello world!</span><br><span class="line">[getting-started] Hello world!</span><br></pre></td></tr></table></figure><p>同样的，我们可以通过kubectl工具查看当前部署的 POD：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods                                            </span><br><span class="line">NAME              READY     STATUS    RESTARTS   AGE</span><br><span class="line">getting-started   1/1       Running   0          1m</span><br></pre></td></tr></table></figure><p>然后我们可以打印出上面的 POD 的详细信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod getting-started  -o yaml</span><br><span class="line">...</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: gcr.io/k8s-skaffold/skaffold-example:811875a31d122f07a30dfca0c0058eb44b2c7100b2794a94f9fd52e639e97fff</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    name: getting-started</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们可以看到我们部署的 POD 的镜像地址，和我们已有的 docker 镜像地址和标签是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images |grep skaffold                                </span><br><span class="line">gcr.io/k8s-skaffold/skaffold-example                     811875a31d122f07a30dfca0c0058eb44b2c7100b2794a94f9fd52e639e97fff   811875a31d12        About a minute ago   271MB</span><br></pre></td></tr></table></figure><p>现在，我们来更改下我们的main.go文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">fmt.Println(&quot;Hello lyz!&quot;)</span><br><span class="line">time.Sleep(time.Second * 1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们保存该文件后，观察 POD 的输出信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Starting build...</span><br><span class="line">Found [docker-for-desktop] context, using local docker daemon.</span><br><span class="line">Sending build context to Docker daemon  6.144kB</span><br><span class="line">Step 1/5 : FROM golang:1.9.4-alpine3.7</span><br><span class="line"> ---&gt; fb6e10bf973b</span><br><span class="line">Step 2/5 : WORKDIR /go/src/github.com/GoogleCloudPlatform/skaffold/examples/getting-started</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 8f1eabcc41a2</span><br><span class="line">Step 3/5 : CMD [&quot;./app&quot;]</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 8c65b0140915</span><br><span class="line">Step 4/5 : COPY main.go .</span><br><span class="line"> ---&gt; 9fc3e7aaff40</span><br><span class="line">Step 5/5 : RUN go build -o app main.go</span><br><span class="line"> ---&gt; Running in 508b97f29e88</span><br><span class="line"> ---&gt; 811875a31d12</span><br><span class="line">Successfully built 811875a31d12</span><br><span class="line">Successfully tagged 7c393e3a0367411d5e7bec05ae632eb5:latest</span><br><span class="line">Successfully tagged gcr.io/k8s-skaffold/skaffold-example:811875a31d122f07a30dfca0c0058eb44b2c7100b2794a94f9fd52e639e97fff</span><br><span class="line">Build complete in 1.706332689s</span><br><span class="line">Starting deploy...</span><br><span class="line">Deploying k8s-pod.yaml...</span><br><span class="line">Deploy complete in 253.419235ms</span><br><span class="line">Watching for changes...</span><br><span class="line">[getting-started] Hello lyz!</span><br><span class="line">[getting-started] Hello lyz!</span><br><span class="line">[getting-started] Hello lyz!</span><br></pre></td></tr></table></figure><p>修改完文件保存之后，我们没有做任何操作，就看见我们的修改结果，同样我们可以用上面的样式去查看下 POD 里面的镜像标签是已经更改过了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我这里为了说明Skaffold的使用，可能描述显得有点拖沓，但是当你自己去使用的时候，就完全能够感受到Skaffold为开发kubernetes应用带来的方便高效，大大的提高了我们的生产力。 另外在kubernetes开发自动化工具领域，还有一些其他的选择，比如Azure的Draft、Datawire 的 Forge 以及 Weavework 的 Flux，大家都可以去使用一下，其他微软的Draft是和Helm结合得非常好，不过Skaffold当然也是支持的，工具始终是工具，能为我们提升效率的就是好工具，不过从开源的角度来说，信 Google 准没错。</p><p>是不是感觉好神奇的样子，容器跟k8s的自动化让我有点惊讶，虽然对k8s还不是很了解，但是通过今天的操作让我对它充满了兴趣，接下来再慢慢深入。如此自动化的运维开发，相信对于开发和测试的效率会有一个质的提升，真心希望公司也能尽快投入到k8s的环保～～～</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/GoogleCloudPlatform/skaffold" target="_blank" rel="noopener">https://github.com/GoogleCloudPlatform/skaffold</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker-Kubernetes集群-Skaffold快速迭代本地开发应用&quot;&gt;&lt;a href=&quot;#Docker-Kubernetes集群-Skaffold快速迭代本地开发应用&quot; class=&quot;headerlink&quot; title=&quot;Docker+Kubernete
      
    
    </summary>
    
      <category term="Docker" scheme="http://luyaoze.github.io/categories/Docker/"/>
    
      <category term="Kubernetes" scheme="http://luyaoze.github.io/categories/Docker/Kubernetes/"/>
    
      <category term="Skaffold" scheme="http://luyaoze.github.io/categories/Docker/Kubernetes/Skaffold/"/>
    
    
      <category term="Docker" scheme="http://luyaoze.github.io/tags/Docker/"/>
    
      <category term="运维" scheme="http://luyaoze.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>容器的功能扩展</title>
    <link href="http://luyaoze.github.io/2018/03/30/%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95/"/>
    <id>http://luyaoze.github.io/2018/03/30/容器的功能扩展/</id>
    <published>2018-03-30T13:19:36.000Z</published>
    <updated>2018-03-30T16:11:08.766Z</updated>
    
    <content type="html"><![CDATA[<p><strong>容器的功能扩展</strong></p><hr><ul><li><p>ApplicationContext</p><p>  ApplicationContext和BeanFactory两者都是用于加载Bean的，但是相比之下，ApplicationContext提供更多的扩展功能，简单一点说：ApplicationContext包含BeanFactory的所有功能。通常建议比BeanFactory优先，除非在一些限制的场合，比如字节长度对内存有很大的影响时（Applet）。绝大多数的“典型的”企业应用和系统，ApplicationContext就是你需要使用的。</p><ul><li><p>使用BeanFactory的方式加载XML</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory bf = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">"beanFactoryTrest.xml"</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用ApplicationContent的方式加载XML</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext bf = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beanFactoryTrest.xml"</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><ul><li><p>ClassPathXmlApplicationContext初始化步骤</p><p>  ClassPathXmlApplicationContex是Spring中ApplicationContext接口的默认实现。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）初始化前的准备工作，例如对系统属性或者环境变量进行准备及验证。</p><pre><code>在某种情况下项目的使用需要读取某些系统变量，而这个变量的设置可能会影响着系统的正确性，那么ClassPathXmlApplicationContext为我们提供中的这个准备函数就显得非常必要，它可以在Spring启动的时候提前对必须的变量进行存在性验证。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">initPropertySources();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validate that all properties marked as required are resolvable</span></span><br><span class="line"><span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line"><span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）初始化BeanFactory，并进行XML文件读取。</p><pre><code>由于ClassPathXmlApplicationContext包含着BeanFactory所提供的一切特征，那么在这一步骤中会复用BeanFactory中的配置文件读取解析及其他功能，这一步之后，ClassPathXmlApplicationContext实际上就已经包含了BeanFactory所提供的功能，也就是可以进行Bean的提取等操作了。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">refreshBeanFactory();</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）对BeanFactory进行各种功能填充</p><pre><code>@Qualifier和@Autowired应该是大家非常熟悉的注解，那么这两个注解正是在这一步骤中增加的支持。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Tell the internal bean factory to use the context's class loader etc.</span></span><br><span class="line">beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line"><span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line"><span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register default environment beans.</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）子类覆盖方法做额外的处理。</p><pre><code>Spring之所以强大，为世人所推崇，除了功能上为大家提供了便利外，还有一方面是它的完美架构，开放式的架构让使用它的程序猿很容易根据业务需要扩展已经存在的功能。这种开放式的设计在Spring中随处可见，例如在本例中就提供了一个空的函数实现postProcessBeanFactory来方便程序员在业务上做进一步扩展。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）激活各种Beanfactory处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line"><span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（6）注册拦截bean创建的bean处理器，这里只是注册，真正的调用是在getBean的时候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（7）为上下文初始化Message源，即对不同语言的消息体进行国际化处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line"><span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line"><span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line"><span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line"><span class="comment">// registered already.</span></span><br><span class="line">hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Using MessageSource ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line">dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line"><span class="keyword">this</span>.messageSource = dms;</span><br><span class="line">beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Unable to locate MessageSource with name '"</span> + MESSAGE_SOURCE_BEAN_NAME +</span><br><span class="line"><span class="string">"': using default ["</span> + <span class="keyword">this</span>.messageSource + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（8）初始化应用消息广播器，并放入“applicationEventMulticaster”bean中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line"><span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Unable to locate ApplicationEventMulticaster with name '"</span> +</span><br><span class="line">APPLICATION_EVENT_MULTICASTER_BEAN_NAME +</span><br><span class="line"><span class="string">"': using default ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（9）留给子类来初始化其他的bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（10）在所有注册的bean中查找listener bean，注册到消息广播器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Register statically specified listeners first.</span></span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（11）初始化剩下的单实例（非惰性的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line"><span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line"><span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> StringValueResolver() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（12）完成刷新过程，通知生命周期处理器lifecycleProcessor刷新过程，同时发出ContenxRefreshEvent通知别人。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish the final event.</span></span><br><span class="line">publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><p>finishRefresh</p><p>  在Spring中还提供了Lifecycle接口，Lifecycle中包含start/stop方法，实现了此接口后Spring会保证在启动的时候调用其start方法开始声明周期，并在Spring关闭的时候调用stop方法来结束生命周期，通常用来配置后台程序，在启动之后一直运行（如对MQ进行轮询等）。而ApplicationContext的初始化最后正是保证了这一功能的实现。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span></span>&#123;</span><br><span class="line">    initLifecycleProcessor();</span><br><span class="line">    getLifecycleProcessor().onRefesh();</span><br><span class="line">    publicEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.initLifecycleProcessor</p><pre><code>当ApplicationContext启动或停止时，它会通过LifecycleProcessor来对所有声明的bean的周期做状态更新，而在LifecycleProcessor的使用前首先需要初始化。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initLifecycleProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"><span class="keyword">this</span>.lifecycleProcessor =</span><br><span class="line">beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Using LifecycleProcessor ["</span> + <span class="keyword">this</span>.lifecycleProcessor + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">DefaultLifecycleProcessor defaultProcessor = <span class="keyword">new</span> DefaultLifecycleProcessor();</span><br><span class="line">defaultProcessor.setBeanFactory(beanFactory);</span><br><span class="line"><span class="keyword">this</span>.lifecycleProcessor = defaultProcessor;</span><br><span class="line">beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, <span class="keyword">this</span>.lifecycleProcessor);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Unable to locate LifecycleProcessor with name '"</span> +</span><br><span class="line">LIFECYCLE_PROCESSOR_BEAN_NAME +</span><br><span class="line"><span class="string">"': using default ["</span> + <span class="keyword">this</span>.lifecycleProcessor + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.onRefresh</p><pre><code>启动所有实现了Lifecycle接口的bean。该方法在ApplicationContext中定义为空方法，需要对应的子类去实现，也正符合Spring面向对象的实现方式。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是实现了Lifecycle接口的bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">startBeans(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">this</span>.running = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBeans</span><span class="params">(<span class="keyword">boolean</span> autoStartupOnly)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();</span><br><span class="line">Map&lt;Integer, LifecycleGroup&gt; phases = <span class="keyword">new</span> HashMap&lt;Integer, LifecycleGroup&gt;();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, ? extends Lifecycle&gt; entry : lifecycleBeans.entrySet()) &#123;</span><br><span class="line">Lifecycle bean = entry.getValue();</span><br><span class="line"><span class="keyword">if</span> (!autoStartupOnly || (bean <span class="keyword">instanceof</span> SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) &#123;</span><br><span class="line"><span class="keyword">int</span> phase = getPhase(bean);</span><br><span class="line">LifecycleGroup group = phases.get(phase);</span><br><span class="line"><span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">group = <span class="keyword">new</span> LifecycleGroup(phase, <span class="keyword">this</span>.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);</span><br><span class="line">phases.put(phase, group);</span><br><span class="line">&#125;</span><br><span class="line">group.add(entry.getKey(), bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!phases.isEmpty()) &#123;</span><br><span class="line">List&lt;Integer&gt; keys = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(phases.keySet());</span><br><span class="line">Collections.sort(keys);</span><br><span class="line"><span class="keyword">for</span> (Integer key : keys) &#123;</span><br><span class="line">phases.get(key).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.publishEvent</p><pre><code>当完成ApplicationContext初始化的时候，要通过Spring中的事件发布机制来发出ContextRefreshEvent事件，以保证对应的监听器可以做进一步的逻辑处理。    </code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">publishEvent(event, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;容器的功能扩展&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ApplicationContext&lt;/p&gt;
&lt;p&gt;  ApplicationContext和BeanFactory两者都是用于加载Bean的，但是相比之下，ApplicationC
      
    
    </summary>
    
      <category term="java" scheme="http://luyaoze.github.io/categories/java/"/>
    
      <category term="spring" scheme="http://luyaoze.github.io/categories/java/spring/"/>
    
      <category term="ioc" scheme="http://luyaoze.github.io/categories/java/spring/ioc/"/>
    
    
      <category term="ioc" scheme="http://luyaoze.github.io/tags/ioc/"/>
    
  </entry>
  
  <entry>
    <title>Bean的解析和加载</title>
    <link href="http://luyaoze.github.io/2018/03/29/%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://luyaoze.github.io/2018/03/29/默认标签的解析/</id>
    <published>2018-03-28T16:16:37.000Z</published>
    <updated>2018-03-28T18:57:46.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bean的解析和加载"><a href="#Bean的解析和加载" class="headerlink" title="Bean的解析和加载"></a>Bean的解析和加载</h2><ul><li><p><strong>bean标签的解析和注册</strong></p><p>  （1）首先委托BeanDefinitionDelegate类的parseBeanDefinitionElement方法进行元素解析，返回BeanDefinitionHolder类型的实例bdHolder，经过这个方法之后，bdHolder实例已经包含我们配置文件中配置的各种属性了，例如class、name、id、alias之类的属性了。<br>  （2）当返回bdHolder不为空的情况下若存在默认标签的子节点下再有自定义属性，还需要再次对自定义标签进行解析。<br>  （3）完成解析之后，需要对解析后的bdHolder进行注册，同样，注册操作委托给BeanDefinitionReaderUtils的registerBeanDefinition方法。<br>  （4）最后发出响应事件，通知相关的监听器，这个bean已经加载完成了。</p></li></ul><hr><ul><li><strong>bean的加载</strong></li></ul><p>（1）转换对应的beanName</p><pre><code>去除FactoryBean的修饰符，也就是如果name=&quot;&amp;aa&quot;,name会首先去除&amp;而使name=“aa”。取指定alias所表示的最终beanName，例如别名A指向名称为B的bean则返回B；若别名指向别名B，别名B又指向名称为C的bean则返回C。</code></pre><p>（2）尝试从缓存中加载单例。</p><pre><code>单例在spring的同一容器内只会被创建一次，后续再获取bean，就直接从单例缓存中获取了。当然这里也只是尝试加载，首先尝试从缓存中加载，如果加载不成功则再次尝试从singlentonFactories中加载。因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候避免循环依赖，在spring中创建bean的原则是不等bean创建完成就会将创建bean的ObjectFactory提早曝光加入到缓存中，一旦一下个bean创建的时候就需要依赖上一个bean则直接使用ObjectFactory。</code></pre><p>（3）bean的实例化</p><pre><code>如果从缓存中得到了bean的原始状态，则需要对bean进行实例化。缓存中记录的只是最原始的bean状态，并不一定是我们最终想要的bean。假如我们需要工厂bean进行处理，那么我们这里得到的其实是工厂bean的初始状态，但是我们真正需要的是工厂bean中定义的factory-method方法中返回的bean，而getObjectForBeanInstance就是完成这个工作的。</code></pre><p>（4）原型模式的依赖检查</p><pre><code>只有在单例的情况下才会尝试解决循环依赖，如果存在A中有B的属性，B中有A的属性，那么当依赖注入的时候，就会产生当A还未创建完的时候因为对于B的创建再次返回创建A，造成循环依赖，也就是情况：isPrototypeCurrentlyIncreation(beanName)判断true。</code></pre><p>（5）检测parentBeanFactory</p><p>（6）将存储XML配置文件的GernericBeanDefinition转换为RootBeanDefinition.</p><pre><code>因为XML配置文件中读取到的bean信息是存储在GernericBeanDefinition中的，但是所有的bean后续处理都是针对RootBeanDefinition的，所以这里要进行一个转换，转换的同时如果父类bean不为空的话，则会一并合并父类的属性。</code></pre><p>（7）寻找依赖</p><pre><code>因为bean的初始化过程中很可能会用到某些属性，而某些属性很肯能是动态配置的，并且配置成依赖于其他的bean，那么这个时候就有必要先加载依赖的bean，所以在spring的加载顺序中，在初始化某一个bean的时候都首先会初始化这个bean所对应的依赖。</code></pre><p>（8）针对不同的scope进行bean的创建<br>（9）类型转换</p><hr><ul><li><strong>FactoryBean的使用</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>T getObject():返回由FactoryBean创建的bean实例，如果isSingleton（）返回true，则该实例会放到Spring容器中单例缓存池中。</li><li>boolean isSingleton()：返回由FactoryBean创建的bean实例的作用域是singleton还是prototype。</li><li>Class&lt;?&gt; getObjectType()：返回FactoryBean创建的bean类型。</li></ul><hr><ul><li><p><strong>循环依赖</strong></p><p>  循环依赖就是循环引用，就是两个或多个bean相互之间的持有对方，比如CircleA引用CircleB。CircleB引用CircleC，CircleC引用CircleA，则他们最终反映为一个环。此处不是循环调用，循环调用是方法之间的环调用。循环依赖是无法解决的，除非有最终条件，否则就是死循环，最终导致内存溢出错误。</p></li><li><p>Spring如何解决循环依赖</p><p>  （1）构造器循环依赖</p><pre><code>Spring容器将每一个正在创建的bean标识符放在一个“当前创建bean池”中，bean标识符在创建过程中将一直保持在这个池中，因此如果创建bean过程中发现自己已经在“当前创建bean池”里时，将抛出BeanCurrentlyCreationException异常表示循环依赖；而对于创建完毕的bean将从“当前创建bean池”中清楚掉。</code></pre><p>  （2）setter循环依赖</p><pre><code>表示对于setter注入造成的循环依赖是通过Spring容器提前暴露刚完成构造器注入但未完成其他步骤（如setter注入）的bean来完成的，而且只能解决单例作用域的bean循环依赖。通过暴露一个单例工厂方法，从而使其他bean能引用到该bean。</code></pre><p>  （3）prototype范围的依赖处理</p><pre><code>对于“prototype“作用域bean，Spring容器无法完成依赖注入，因为Spring容器不进行缓存”prototype“作用域的bean，因此无法提前暴露一个创建中的bean。</code></pre></li></ul><hr><ul><li><p><strong>创建bean</strong></p><p>  （1）如果是单例则需要首先清楚缓存。</p><p>  （2）实例化bean，将BeanDefinition转换为BeanWrapper。</p><pre><code>* 如果存在工厂方法则使用工厂方法进行初始化* 一个类有多个构造函数，每个构造函数都有不同的参数，所以要根据参数锁定构造函数进行初始化。* 如果既不存在工厂方法也不存在带有参数的构造函数，则使用默认的构造函数进行bean的实例化。</code></pre><p>  （3）MergerBeanDefinitionPostProcessor的应用</p><pre><code>bean合并处理后，Autowired注解正是通过此方法实现诸如类型的预解析。</code></pre><p>  （4）依赖处理</p><p>  （5）属性填充</p><p>  （6）循环依赖检查</p><p>  （7）注册DisposableBean</p><pre><code>如果配置了destroy-method，这里需要注册以便于在销毁时调用。</code></pre><p>  （8）完成创建并返回。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Bean的解析和加载&quot;&gt;&lt;a href=&quot;#Bean的解析和加载&quot; class=&quot;headerlink&quot; title=&quot;Bean的解析和加载&quot;&gt;&lt;/a&gt;Bean的解析和加载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;bean标签的解析和注册&lt;/strong&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://luyaoze.github.io/categories/java/"/>
    
    
      <category term="spring" scheme="http://luyaoze.github.io/tags/spring/"/>
    
      <category term="ioc" scheme="http://luyaoze.github.io/tags/ioc/"/>
    
      <category term="bean" scheme="http://luyaoze.github.io/tags/bean/"/>
    
  </entry>
  
  <entry>
    <title>XML的验证模式</title>
    <link href="http://luyaoze.github.io/2018/03/27/XML%E7%9A%84%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://luyaoze.github.io/2018/03/27/XML的验证模式/</id>
    <published>2018-03-26T16:31:10.000Z</published>
    <updated>2018-03-28T18:06:16.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="xml的验证模式"><a href="#xml的验证模式" class="headerlink" title="xml的验证模式"></a>xml的验证模式</h2><ul><li><strong>DTD与XSD区别</strong></li></ul><hr><p>DTD即文档类型定义，是一种XML约束模式语言，是XML文件的验证机制，属于XML文件组成的一部分。DTD是一种保证XML文档格式正确的有效方法，可以通过比较XML文档和DTD文件来看文档是否符合规范，语速和标签使用是否正确。一个DTD文档包含：元素的定义规则，元素间关系的定义规则，元素可使用的属性，可使用的实体或者符号规则。<br>XML Schema语言就是XSD。XML Schema描述文档的结构。可以使用一个指定的XML Schema来验证某个XML文档，以检查该XML文档所允许的结构和内容，并可据检查一个XML文档是否是有效的。XML Schema本身是一个XML文档，它符合XML语法结构。可以通过通用的XML解析器解析它。</p><ul><li><strong>获取Document</strong></li></ul><hr><p>经过验证模式准备的步骤就可以进行Document加载了，同样XmlBeanFactoryReader类对于文档读取并没有亲力亲为，而是委托给DocumentLoader去执行，这里的DocumentLoader是个接口，而真正调用的是DefaultDocumentLoader。</p><ul><li><strong>EntityResolver</strong></li></ul><hr><p>官网解释：如果SAX应用程序需要实现自定义的处理外部实体部分，则必须实现此接口并使用setEntityResolver方法向SAX驱动器注册一个实例。也就是说，对于解析一个XML，SAX首先读取该文档上的声明，根据声明去寻找相对应的DTD定义，以便对文档进行一个验证。默认的寻找规则，即通过网络来下载，并进行验证。<br>EntityResolver的作用是项目本身就可以提供一个如何寻找DTD声明的方法，即由程序来实现寻找DTD声明的过程，比如我们将DTD文件放到项目中某处，在实现时直接将此文档读取并返回SAX即可。这样就避免了通过网络来寻找相应的声明。<br>对于不同的验证模式，Spring使用了不同的解析器进行解析。加载DTD类型的BeansDtdResolver类的resolverEntity是直接街区systemId最后的xx.dtd然后去当前路径下寻找，而加载XSD类型的PluggableSchemaResolver类的resolveEntity是默认到META-INF/Spring.schemas文件中找到systemId所对应的XSD文件进行加载。</p><ul><li><strong>解析及注册BeanDefinitions</strong></li></ul><hr><p>把文件转换为Document后，接下来就是加载。如果需要在加载前后做其他的事情，只需要继承DefaultBeanDefinitionDocymentReader然后重写preProcessXml(root)或者postProcessXml(root)这两个方法。默认的实现这两个方法是空着的，但是，这里使用模板方法模式进行设计，方便后续的扩展。就像面向对象的方法学中常说的一句话，一个类要么是面向继承的设计的，要么就用final修饰。</p><ul><li><strong>profile属性的使用</strong></li></ul><hr><p>注册bean的最开始是对PAOFILE_ATTRIBUTE属性的解析。在web环境中可以在web.xml当中配置Spring.profile.active，有了这个属性就可以方便的进行切换环境，常用的就是切换数据源。<br>对于Bean的申明，一种是默认的XML格式，另一种就是注解模式。</p><ul><li><strong>解析各种属性</strong></li></ul><hr><p>scope–&gt;singleton–&gt;abstract–&gt;lazy-init(如果没有设置或设置成其他字符都会被设置为false)–&gt;autowire–&gt;dependency-check–&gt;depends-on–&gt;autowire-candidate–&gt;primary–&gt;init-method–&gt;destory-method–&gt;factory-method–&gt;factory-bean.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;xml的验证模式&quot;&gt;&lt;a href=&quot;#xml的验证模式&quot; class=&quot;headerlink&quot; title=&quot;xml的验证模式&quot;&gt;&lt;/a&gt;xml的验证模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DTD与XSD区别&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h
      
    
    </summary>
    
      <category term="java" scheme="http://luyaoze.github.io/categories/java/"/>
    
    
      <category term="spring" scheme="http://luyaoze.github.io/tags/spring/"/>
    
      <category term="xml" scheme="http://luyaoze.github.io/tags/xml/"/>
    
  </entry>
  
  <entry>
    <title>IOC（一）</title>
    <link href="http://luyaoze.github.io/2018/03/25/IOC%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://luyaoze.github.io/2018/03/25/IOC（一）/</id>
    <published>2018-03-25T14:07:01.000Z</published>
    <updated>2018-03-28T18:05:53.896Z</updated>
    
    <content type="html"><![CDATA[<p>Spring源码学习（一）</p><h2 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a>DefaultListableBeanFactory</h2><ul><li><strong>DefaultListableBeanFactory</strong>是spring整个bean加载的核心部分，是spring注册及加载bean的默认实现。XmlBeanFactory继承了自DefaultListableBeanFactory，不同的就是XmlBeanFactory中使用了自定义的XmlBeanDefinitionReader，实现了自定义的BeanDefinitionReader读取。</li><li><p><strong>AliasRegistry</strong> - 定义对alias的简单的增删改操作。spring-core模块下的接口.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void registerAlias(String name, String alias);</span><br><span class="line">void removeAlias(String alias);</span><br><span class="line">boolean isAlias(String name);</span><br><span class="line">String[] getAliases(String name);</span><br></pre></td></tr></table></figure></li><li><p><strong>SimpleAliasRegistry</strong> - 使用map作为缓存，对AliasRegistry接口进行实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;String, String&gt; aliasMap = new ConcurrentHashMap(16);</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>SingLetonBeanRegistry</strong> - 定义对单例的注册及获取</li><li><strong>BeanFactory</strong> -定义获取bean及bean的各种属性</li><li><strong>DefaultSingletonBeanRegistry</strong> -继承SimpleAliasRegistry 实现SingletonBeanRegistry接口。</li><li><strong>HierarchicalBeanFactory</strong> -继承自BeanFactory，也就是在BeanFactory的基础上增加了对parentFactory的支持。</li><li><strong>BeanDefinitionRegistry</strong> -继承自AliasRegistry，定义对BeanDefinition的各种增删改操作，默认的实现为DefaultListableBeanFactory。</li><li><strong>FactoryBeanRegistrySupport</strong> -继承自DefaultSingletonBeanRegistry，在原有的基础上增加了对FactoryBean的特殊处理功能。</li><li><strong>ConfigurableBeanFactory</strong> -继承了HierarchicalBeanFactory和SingletonBeanRegistry两个接口，提供配置Factory的各种方法。</li><li><strong>ListableBeanFactory</strong> -继承了BeanFactory，提供各种条件获取bean的配置清单。</li><li><strong>AbstractBeanFactory</strong> -抽象类，继承了FactoryBeanRegistrySupport，实现了ConfigurableBeanFactory接口，对两者的功能进行整合。</li><li><strong>AutowireCapableBeanFactory</strong> -继承自BeanFactory，提供创建bean、自动注入、初始化以及应用bean的后处理器。</li><li><strong>AutowireCapableBeanFactory</strong> -继承了AbstractBeanFactory，实现了AutowireCapableBeanFactory接口。</li><li><strong>ConfigurableListableBeanFactory</strong> -继承了ListableBeanFactory，AutowireCapableBeanFactory，ConfigurableBeanFactory三个接口，beanFactory的配置清单，制定忽略类型及接口等。</li><li><strong>DefaultListableBeanFactory</strong> -综合上面所有的功能，主要是对bean注册后的处理。</li><li><strong>XmlBeanFactory</strong> 对DefaultListableBeanFactory类进行了拓展，主要用于从XML文档中读取BeanDefinition，对于注册Bean都是从父类DefaultListableBeanFactory继承的方法去实现，而唯独与父类不同的的个性化实现就是增加了XmlBeanDefinitionReader类型的reader属性。在XmlBeanFactory中主要使用reader属性对资源进行读取和注册。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring源码学习（一）&lt;/p&gt;
&lt;h2 id=&quot;DefaultListableBeanFactory&quot;&gt;&lt;a href=&quot;#DefaultListableBeanFactory&quot; class=&quot;headerlink&quot; title=&quot;DefaultListableBean
      
    
    </summary>
    
      <category term="java" scheme="http://luyaoze.github.io/categories/java/"/>
    
    
      <category term="spring" scheme="http://luyaoze.github.io/tags/spring/"/>
    
      <category term="ioc" scheme="http://luyaoze.github.io/tags/ioc/"/>
    
  </entry>
  
</feed>
