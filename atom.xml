<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyz的博客</title>
  
  <subtitle>静静地搬砖</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luyaoze.github.io/"/>
  <updated>2018-03-28T18:57:46.672Z</updated>
  <id>http://luyaoze.github.io/</id>
  
  <author>
    <name>卢耀泽</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Bean的解析和加载</title>
    <link href="http://luyaoze.github.io/2018/03/29/%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://luyaoze.github.io/2018/03/29/默认标签的解析/</id>
    <published>2018-03-28T16:16:37.000Z</published>
    <updated>2018-03-28T18:57:46.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bean的解析和加载"><a href="#Bean的解析和加载" class="headerlink" title="Bean的解析和加载"></a>Bean的解析和加载</h2><ul><li><p><strong>bean标签的解析和注册</strong></p><p>  （1）首先委托BeanDefinitionDelegate类的parseBeanDefinitionElement方法进行元素解析，返回BeanDefinitionHolder类型的实例bdHolder，经过这个方法之后，bdHolder实例已经包含我们配置文件中配置的各种属性了，例如class、name、id、alias之类的属性了。<br>  （2）当返回bdHolder不为空的情况下若存在默认标签的子节点下再有自定义属性，还需要再次对自定义标签进行解析。<br>  （3）完成解析之后，需要对解析后的bdHolder进行注册，同样，注册操作委托给BeanDefinitionReaderUtils的registerBeanDefinition方法。<br>  （4）最后发出响应事件，通知相关的监听器，这个bean已经加载完成了。</p></li></ul><hr><ul><li><strong>bean的加载</strong></li></ul><p>（1）转换对应的beanName</p><pre><code>去除FactoryBean的修饰符，也就是如果name=&quot;&amp;aa&quot;,name会首先去除&amp;而使name=“aa”。取指定alias所表示的最终beanName，例如别名A指向名称为B的bean则返回B；若别名指向别名B，别名B又指向名称为C的bean则返回C。</code></pre><p>（2）尝试从缓存中加载单例。</p><pre><code>单例在spring的同一容器内只会被创建一次，后续再获取bean，就直接从单例缓存中获取了。当然这里也只是尝试加载，首先尝试从缓存中加载，如果加载不成功则再次尝试从singlentonFactories中加载。因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候避免循环依赖，在spring中创建bean的原则是不等bean创建完成就会将创建bean的ObjectFactory提早曝光加入到缓存中，一旦一下个bean创建的时候就需要依赖上一个bean则直接使用ObjectFactory。</code></pre><p>（3）bean的实例化</p><pre><code>如果从缓存中得到了bean的原始状态，则需要对bean进行实例化。缓存中记录的只是最原始的bean状态，并不一定是我们最终想要的bean。假如我们需要工厂bean进行处理，那么我们这里得到的其实是工厂bean的初始状态，但是我们真正需要的是工厂bean中定义的factory-method方法中返回的bean，而getObjectForBeanInstance就是完成这个工作的。</code></pre><p>（4）原型模式的依赖检查</p><pre><code>只有在单例的情况下才会尝试解决循环依赖，如果存在A中有B的属性，B中有A的属性，那么当依赖注入的时候，就会产生当A还未创建完的时候因为对于B的创建再次返回创建A，造成循环依赖，也就是情况：isPrototypeCurrentlyIncreation(beanName)判断true。</code></pre><p>（5）检测parentBeanFactory</p><p>（6）将存储XML配置文件的GernericBeanDefinition转换为RootBeanDefinition.</p><pre><code>因为XML配置文件中读取到的bean信息是存储在GernericBeanDefinition中的，但是所有的bean后续处理都是针对RootBeanDefinition的，所以这里要进行一个转换，转换的同时如果父类bean不为空的话，则会一并合并父类的属性。</code></pre><p>（7）寻找依赖</p><pre><code>因为bean的初始化过程中很可能会用到某些属性，而某些属性很肯能是动态配置的，并且配置成依赖于其他的bean，那么这个时候就有必要先加载依赖的bean，所以在spring的加载顺序中，在初始化某一个bean的时候都首先会初始化这个bean所对应的依赖。</code></pre><p>（8）针对不同的scope进行bean的创建<br>（9）类型转换</p><hr><ul><li><strong>FactoryBean的使用</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>T getObject():返回由FactoryBean创建的bean实例，如果isSingleton（）返回true，则该实例会放到Spring容器中单例缓存池中。</li><li>boolean isSingleton()：返回由FactoryBean创建的bean实例的作用域是singleton还是prototype。</li><li>Class&lt;?&gt; getObjectType()：返回FactoryBean创建的bean类型。</li></ul><hr><ul><li><p><strong>循环依赖</strong></p><p>  循环依赖就是循环引用，就是两个或多个bean相互之间的持有对方，比如CircleA引用CircleB。CircleB引用CircleC，CircleC引用CircleA，则他们最终反映为一个环。此处不是循环调用，循环调用是方法之间的环调用。循环依赖是无法解决的，除非有最终条件，否则就是死循环，最终导致内存溢出错误。</p></li><li><p>Spring如何解决循环依赖</p><p>  （1）构造器循环依赖</p><pre><code>Spring容器将每一个正在创建的bean标识符放在一个“当前创建bean池”中，bean标识符在创建过程中将一直保持在这个池中，因此如果创建bean过程中发现自己已经在“当前创建bean池”里时，将抛出BeanCurrentlyCreationException异常表示循环依赖；而对于创建完毕的bean将从“当前创建bean池”中清楚掉。</code></pre><p>  （2）setter循环依赖</p><pre><code>表示对于setter注入造成的循环依赖是通过Spring容器提前暴露刚完成构造器注入但未完成其他步骤（如setter注入）的bean来完成的，而且只能解决单例作用域的bean循环依赖。通过暴露一个单例工厂方法，从而使其他bean能引用到该bean。</code></pre><p>  （3）prototype范围的依赖处理</p><pre><code>对于“prototype“作用域bean，Spring容器无法完成依赖注入，因为Spring容器不进行缓存”prototype“作用域的bean，因此无法提前暴露一个创建中的bean。</code></pre></li></ul><hr><ul><li><p><strong>创建bean</strong></p><p>  （1）如果是单例则需要首先清楚缓存。</p><p>  （2）实例化bean，将BeanDefinition转换为BeanWrapper。</p><pre><code>* 如果存在工厂方法则使用工厂方法进行初始化* 一个类有多个构造函数，每个构造函数都有不同的参数，所以要根据参数锁定构造函数进行初始化。* 如果既不存在工厂方法也不存在带有参数的构造函数，则使用默认的构造函数进行bean的实例化。</code></pre><p>  （3）MergerBeanDefinitionPostProcessor的应用</p><pre><code>bean合并处理后，Autowired注解正是通过此方法实现诸如类型的预解析。</code></pre><p>  （4）依赖处理</p><p>  （5）属性填充</p><p>  （6）循环依赖检查</p><p>  （7）注册DisposableBean</p><pre><code>如果配置了destroy-method，这里需要注册以便于在销毁时调用。</code></pre><p>  （8）完成创建并返回。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Bean的解析和加载&quot;&gt;&lt;a href=&quot;#Bean的解析和加载&quot; class=&quot;headerlink&quot; title=&quot;Bean的解析和加载&quot;&gt;&lt;/a&gt;Bean的解析和加载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;bean标签的解析和注册&lt;/strong&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://luyaoze.github.io/categories/java/"/>
    
    
      <category term="spring" scheme="http://luyaoze.github.io/tags/spring/"/>
    
      <category term="ioc" scheme="http://luyaoze.github.io/tags/ioc/"/>
    
      <category term="bean" scheme="http://luyaoze.github.io/tags/bean/"/>
    
  </entry>
  
  <entry>
    <title>XML的验证模式</title>
    <link href="http://luyaoze.github.io/2018/03/27/XML%E7%9A%84%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://luyaoze.github.io/2018/03/27/XML的验证模式/</id>
    <published>2018-03-26T16:31:10.000Z</published>
    <updated>2018-03-28T18:06:16.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="xml的验证模式"><a href="#xml的验证模式" class="headerlink" title="xml的验证模式"></a>xml的验证模式</h2><ul><li><strong>DTD与XSD区别</strong></li></ul><hr><p>DTD即文档类型定义，是一种XML约束模式语言，是XML文件的验证机制，属于XML文件组成的一部分。DTD是一种保证XML文档格式正确的有效方法，可以通过比较XML文档和DTD文件来看文档是否符合规范，语速和标签使用是否正确。一个DTD文档包含：元素的定义规则，元素间关系的定义规则，元素可使用的属性，可使用的实体或者符号规则。<br>XML Schema语言就是XSD。XML Schema描述文档的结构。可以使用一个指定的XML Schema来验证某个XML文档，以检查该XML文档所允许的结构和内容，并可据检查一个XML文档是否是有效的。XML Schema本身是一个XML文档，它符合XML语法结构。可以通过通用的XML解析器解析它。</p><ul><li><strong>获取Document</strong></li></ul><hr><p>经过验证模式准备的步骤就可以进行Document加载了，同样XmlBeanFactoryReader类对于文档读取并没有亲力亲为，而是委托给DocumentLoader去执行，这里的DocumentLoader是个接口，而真正调用的是DefaultDocumentLoader。</p><ul><li><strong>EntityResolver</strong></li></ul><hr><p>官网解释：如果SAX应用程序需要实现自定义的处理外部实体部分，则必须实现此接口并使用setEntityResolver方法向SAX驱动器注册一个实例。也就是说，对于解析一个XML，SAX首先读取该文档上的声明，根据声明去寻找相对应的DTD定义，以便对文档进行一个验证。默认的寻找规则，即通过网络来下载，并进行验证。<br>EntityResolver的作用是项目本身就可以提供一个如何寻找DTD声明的方法，即由程序来实现寻找DTD声明的过程，比如我们将DTD文件放到项目中某处，在实现时直接将此文档读取并返回SAX即可。这样就避免了通过网络来寻找相应的声明。<br>对于不同的验证模式，Spring使用了不同的解析器进行解析。加载DTD类型的BeansDtdResolver类的resolverEntity是直接街区systemId最后的xx.dtd然后去当前路径下寻找，而加载XSD类型的PluggableSchemaResolver类的resolveEntity是默认到META-INF/Spring.schemas文件中找到systemId所对应的XSD文件进行加载。</p><ul><li><strong>解析及注册BeanDefinitions</strong></li></ul><hr><p>把文件转换为Document后，接下来就是加载。如果需要在加载前后做其他的事情，只需要继承DefaultBeanDefinitionDocymentReader然后重写preProcessXml(root)或者postProcessXml(root)这两个方法。默认的实现这两个方法是空着的，但是，这里使用模板方法模式进行设计，方便后续的扩展。就像面向对象的方法学中常说的一句话，一个类要么是面向继承的设计的，要么就用final修饰。</p><ul><li><strong>profile属性的使用</strong></li></ul><hr><p>注册bean的最开始是对PAOFILE_ATTRIBUTE属性的解析。在web环境中可以在web.xml当中配置Spring.profile.active，有了这个属性就可以方便的进行切换环境，常用的就是切换数据源。<br>对于Bean的申明，一种是默认的XML格式，另一种就是注解模式。</p><ul><li><strong>解析各种属性</strong></li></ul><hr><p>scope–&gt;singleton–&gt;abstract–&gt;lazy-init(如果没有设置或设置成其他字符都会被设置为false)–&gt;autowire–&gt;dependency-check–&gt;depends-on–&gt;autowire-candidate–&gt;primary–&gt;init-method–&gt;destory-method–&gt;factory-method–&gt;factory-bean.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;xml的验证模式&quot;&gt;&lt;a href=&quot;#xml的验证模式&quot; class=&quot;headerlink&quot; title=&quot;xml的验证模式&quot;&gt;&lt;/a&gt;xml的验证模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DTD与XSD区别&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h
      
    
    </summary>
    
      <category term="java" scheme="http://luyaoze.github.io/categories/java/"/>
    
    
      <category term="spring" scheme="http://luyaoze.github.io/tags/spring/"/>
    
      <category term="xml" scheme="http://luyaoze.github.io/tags/xml/"/>
    
  </entry>
  
  <entry>
    <title>IOC（一）</title>
    <link href="http://luyaoze.github.io/2018/03/25/IOC%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://luyaoze.github.io/2018/03/25/IOC（一）/</id>
    <published>2018-03-25T14:07:01.000Z</published>
    <updated>2018-03-28T18:05:53.896Z</updated>
    
    <content type="html"><![CDATA[<p>Spring源码学习（一）</p><h2 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a>DefaultListableBeanFactory</h2><ul><li><strong>DefaultListableBeanFactory</strong>是spring整个bean加载的核心部分，是spring注册及加载bean的默认实现。XmlBeanFactory继承了自DefaultListableBeanFactory，不同的就是XmlBeanFactory中使用了自定义的XmlBeanDefinitionReader，实现了自定义的BeanDefinitionReader读取。</li><li><p><strong>AliasRegistry</strong> - 定义对alias的简单的增删改操作。spring-core模块下的接口.</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void registerAlias(<span class="keyword">String</span> <span class="keyword">name</span>, <span class="keyword">String</span> <span class="keyword">alias</span>);</span><br><span class="line">void removeAlias(<span class="keyword">String</span> <span class="keyword">alias</span>);</span><br><span class="line">boolean isAlias(<span class="keyword">String</span> <span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">String</span>[] getAliases(<span class="keyword">String</span> <span class="keyword">name</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>SimpleAliasRegistry</strong> - 使用map作为缓存，对AliasRegistry接口进行实现。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; aliasMap = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">16</span>);</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>SingLetonBeanRegistry</strong> - 定义对单例的注册及获取</li><li><strong>BeanFactory</strong> -定义获取bean及bean的各种属性</li><li><strong>DefaultSingletonBeanRegistry</strong> -继承SimpleAliasRegistry 实现SingletonBeanRegistry接口。</li><li><strong>HierarchicalBeanFactory</strong> -继承自BeanFactory，也就是在BeanFactory的基础上增加了对parentFactory的支持。</li><li><strong>BeanDefinitionRegistry</strong> -继承自AliasRegistry，定义对BeanDefinition的各种增删改操作，默认的实现为DefaultListableBeanFactory。</li><li><strong>FactoryBeanRegistrySupport</strong> -继承自DefaultSingletonBeanRegistry，在原有的基础上增加了对FactoryBean的特殊处理功能。</li><li><strong>ConfigurableBeanFactory</strong> -继承了HierarchicalBeanFactory和SingletonBeanRegistry两个接口，提供配置Factory的各种方法。</li><li><strong>ListableBeanFactory</strong> -继承了BeanFactory，提供各种条件获取bean的配置清单。</li><li><strong>AbstractBeanFactory</strong> -抽象类，继承了FactoryBeanRegistrySupport，实现了ConfigurableBeanFactory接口，对两者的功能进行整合。</li><li><strong>AutowireCapableBeanFactory</strong> -继承自BeanFactory，提供创建bean、自动注入、初始化以及应用bean的后处理器。</li><li><strong>AutowireCapableBeanFactory</strong> -继承了AbstractBeanFactory，实现了AutowireCapableBeanFactory接口。</li><li><strong>ConfigurableListableBeanFactory</strong> -继承了ListableBeanFactory，AutowireCapableBeanFactory，ConfigurableBeanFactory三个接口，beanFactory的配置清单，制定忽略类型及接口等。</li><li><strong>DefaultListableBeanFactory</strong> -综合上面所有的功能，主要是对bean注册后的处理。</li><li><strong>XmlBeanFactory</strong> 对DefaultListableBeanFactory类进行了拓展，主要用于从XML文档中读取BeanDefinition，对于注册Bean都是从父类DefaultListableBeanFactory继承的方法去实现，而唯独与父类不同的的个性化实现就是增加了XmlBeanDefinitionReader类型的reader属性。在XmlBeanFactory中主要使用reader属性对资源进行读取和注册。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring源码学习（一）&lt;/p&gt;
&lt;h2 id=&quot;DefaultListableBeanFactory&quot;&gt;&lt;a href=&quot;#DefaultListableBeanFactory&quot; class=&quot;headerlink&quot; title=&quot;DefaultListableBean
      
    
    </summary>
    
      <category term="java" scheme="http://luyaoze.github.io/categories/java/"/>
    
    
      <category term="spring" scheme="http://luyaoze.github.io/tags/spring/"/>
    
      <category term="ioc" scheme="http://luyaoze.github.io/tags/ioc/"/>
    
  </entry>
  
</feed>
